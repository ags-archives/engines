<html>

<head>
<meta name="GENERATOR" content="Tsf2Html (c) 1999 Chris Jones">
<title>Adventure Creator v2.00</title></head>

<body>
<p align="right"><font face="tahoma, verdana" size=5 color=#0000A0><b><u>
Adventure Game Studio v2.31</u></b></font><br>
<font face="tahoma, verdana" size=2>Copyright 1999-2002 Chris Jones</font></p><hr>
<p>
Adventure Game Studio (or AGS for short) allows you to create your own
point-and-click adventure games, like the older Sierra games (Space Quest 4,
King's Quest 5-6, etc). It includes an easy-to-use Integrated Development
Environment, and you do not need any programming experience to make a game
using it.
<br>For more advanced users, AGS supports scripting, where you can write a sort
of program which allows you to have great control over the game.
<br>By default, AGS will create Sierra-style adventure games, with the pop-up icon
bar, and right-click cycles through the modes (walk, look, use, speak).
However, you can change the interface completely using the Interface Editor
to make Lucasarts-style or any other type of interface you want.
<br>AGS handles many parts of the system for you, like load/save game, character
movement and object animations.
<p>
(You may have known this program previously as the Adventure Creator: the last
version was Adventure Creator v1.14. The reasons for the name change are
described in the &quot;Upgrading from v1&quot; section of this document).
<p>
<font color=#0000A0><b><u>
AGS system requirements (for 256-colour games):
</u></b></font>
<br><ul><li>486 or higher processor (DX4/100 or better recommended)</li>
<li>VGA display (SVGA optional)</li>
<li>at least 16 Mb RAM, but 32 Mb is recommended</li>
<li>MS-DOS 5.00 or higher, Windows 95/98/ME or Windows 2000.</li>
<li>Games made for Windows require DirectX 7 or higher.</li>
<li>About 20 Mb free disk space (may need more or less, depending on the game)</li>
<li>Sound card optional (supports Adlib, Sound Blaster and General MIDI for
music; Sound Blaster and ESS Audiodrive for digital sound).</li></ul>
<p>
<font color=#0000A0><b><u>
Hi-colour games also require the above, but in addition:
</u></b></font>
<br><ul><li>Pentium or higher processor, at least 233 Mhz</li>
<li>SVGA display with VESA driver</li>
<li>32 MB RAM</li>
<li>1 MB Video RAM required, 2 Mb recommended</li></ul>
<p>
This is the HTML version of the manual. A plain text version is also
available. This HTML version hasn't been properly formatted, so some of
the indentation, especially in the command reference, looks ugly. Read
the text version instead if you find this hard to read.
<p>
<font color=#0000A0 size="+1"><u><b>1. Contents</b></u></font><br>
<br>This document contains the following sections:
<br> 1. Contents (this is it)
<br> 2. Using the run-time engine
<br> 3. Tutorial - introduction to how to make a simple game
<br> 4. Other features - not covered in the tutorial
<br> 5. Upgrading from AC v1
<br> 6. Reference - interaction events &amp; commands, text script commands
<br> 7. Troubleshooting
<br> 8. Contacting the Author
<br> 9. Credits
<p>
<font color=#0000A0 size="+1"><u><b>2. Using the run-time engine</b></u></font><br>
<br>The engine (also called the &quot;interpreter&quot;) is what runs your game and is what
the end player will use.
<br>If you are using the default interface, then you use the right mouse button to
cycle between the available 'modes', and the left button to use the current
mode on the mouse position. You can also move the mouse to the top of the
screen to bring up the icon bar where you can directly select a mode.
<br>To exit the engine, press Ctrl-Q. You can save your game position using F5
and restore with F7.
<br>The controls described above work with the default setup; however, you can
customize your game to use a different interface and shortcut keys.
<p>
<font color=#00A000><u><b>2.1 THE DEMO GAME</b></u></font><br>
<br>The first thing you'll probably want to do is to run the demo game. This
short game (made up of 9 screens) will show you some of what AGS can do. It
doesn't demonstrate all the features, though - you'll find about them for
yourself. To run the demo, type DEMO and press return (or double-click the
DEMO.BAT file in Windows).
<p>
<font color=#00A000><u><b>2.2 WINDOWS 2000 AND WINDOWS XP ISSUES</b></u></font><br>
<br>I thought I'd better bring this up quite early on because it's important -
if you are not using Windows 2000 or XP then skip this paragraph.
<br>The AGS engine comes in two flavours - a Windows DirectX version and a DOS
version. The DOS version runs on DOS (obviously), Windows 95, 98 and Me.
The Windows version runs on Windows 95, 98, Me, 2000 and XP.
<br>However, the AGS Editor is currently DOS-based. This may work for you in
Windows 2000, or the screen may go blank when you try to run it - this
depends on your graphics card. If it doesn't work I'm sorry but there's
nothing I can do until the Windows editor is finished (which will be quite a
while). Currently I have a duel boot between Windows 95 and 2000 to allow
me to test all versions.
<p>
<font color=#00A000><u><b>2.3 RUN-TIME ENGINE SETUP</b></u></font><br>
<br>By default, the engine will automatically detect the player's sound card, and
use the low-resolution 320x200 display mode. However, the player can override
the autodetection if it cannot detect their sound card. To run the setup
program, type SETUP and press return.
<br>In the Setup program, the user can choose their sound effect card (used for
sound effects like WAVs, and also for MOD and XM music) and their MIDI music
card (used for MIDI music only).
<br>They can also choose what screen resolution they would like to run the engine
using. The available choices are 320x200, 640x400 and 960x600. The higher
resolution gives a better quality picture in the game, but slows the game down.
Generally, use the 320x200 mode for computers which are Pentium-100 or slower.
The 640x400 mode is the best choice and will work with Pentium-120 or higher
computers. The 960x600 mode should only be used with very high-spec machines
(ie. Pentium-II and better machines).
<br>Note however, that the picture quality is only as good as it was drawn, so if
all the scenes in your game are drawn at 640x400, then using the 960x600
resolution will not help - it will just slow the game down.
<p>
<font color=#00A000><u><b>2.3.1 THE WAVETABLE SYNTH MIDI DRIVER</b></u></font><br>
<br>New in v2.02 is a MIDI driver called &quot;Software wavetable synth&quot;. This uses
a MIDI patch set to play MIDI music through the digital sound driver, thus
meaning that the music will sound the same on all sound cards. This is
particularly useful for standard Sound Blaster cards, where the built-in MIDI
chips on the card sound very crappy.
<br>This driver is never autodetected; the player must choose it specifically
by running the Setup program. Note that since it uses the digital driver to
play the sound, you must have a digital sound card installed in the system
for it to work. Also note that it will slightly slow down the game over just
using a standard MIDI driver.
<br>To use the wavetable driver, you need to get the General MIDI patch set, which
you can download from the AGS website (it's 1.5 Mb, that's why it's only
available seperately). If the patch set is not found in the AGS directory,
then Setup will not allow you to choose the driver.
<p>
<font color=#0000A0 size="+1"><u><b>3. Tutorial</b></u></font><br>
<br>This section will introduce you to the AGS by leading you through how to
create a simple game.
<p>
<font color=#00A000><u><b>3.1 CREATING YOUR FIRST ROOM</b></u></font><br>
<br>In adventure games, the character moves from one screen to another, and each
screen consists of a pre-rendered background drawing with objects  and
characters on top of it to give interaction. A screen is also called a &quot;room&quot;.
First, you need to draw a background scene for the first room. You do this in
your favourite paint program. The size must be either 320x200 or 640x400, and
you must make sure that the colour depth is set to 8-bit or 16-bit colour.
Save it as a BMP or PCX file (TIP: a PCX will give smaller file sizes since
PCXs are compressed, whereas BMPs are not).
<br>Load the AGS editor (type ROOMEDIT and press return). It will ask you which
game you want to edit. Highlight &quot;NEW GAME&quot;, then click OK. Here you type the
directory name for the game (up to 8 characters max), and press return. You
have now created a new game.
<br>Choose the &quot;ROOM&quot; tab if it is not already displayed (The tabs are the four
buttons along the bottom of the screen). On the left hand side of the screen,
there are five other buttons, called &quot;Setup screen&quot; down to &quot;Objects&quot;. By
clicking one of these, you choose which sub-mode the editor is in.
<br>NOTE: Don't let the name &quot;RoomEdit&quot; fool you - it is, in fact, your integrated
environment for development of the whole game, not just the rooms.
<p>
First of all we need to import a background scene for the room. Click on
&quot;Setup screen&quot; and then choose the &quot;Load scene...&quot; button on the main panel.
You will see a file selector where you should now find the background scene
graphic which you drew. Click OK, and it will be imported.
<br>(If you get a message asking you what resolution the picture is drawn for,
choose the appropriate button. For example, if you have drawn a 640x400-sized
scene, then click &quot;640x400&quot;).
<br>You will see the top half of the picture, on the screen, along with two scroll
bars which you can use to see the rest of it.
<br>NOTE: The Editor always runs in the 320x200 graphics mode. If you have drawn
a high-resolution picture at 640x400 it will seem to have been reduced. This
is only in the editor and you will see the proper picture in the actual game.
You can check that it was imported properly by clicking the &quot;Full screen&quot;
button which gives you a preview at the proper resolution.
<br>NOTE: The Room Editor has on-line context sensitive help (and now with a new
graphical help reader!) Press F1 at any time.
<p>
<font color=#00A000><u><b>3.1.1 WALKABLE AREAS</b></u></font><br>
<br>Now that you have the background scene, you need to tell the game where the
player character is allowed to walk. You do this using walkable areas. Choose
the &quot;Walkable areas&quot; mode from the left-hand button list.
<br>Everywhere that the character's feet are allowed to walk, you must make
walkable. Adding walkable areas works in a similar way to most paint programs:
you use three tools (line, fill and freehand) to draw them.
<br>You will probably want to start off with the &quot;Line&quot; tool - click the button
in the main panel. Now, draw round the outline of the walkable areas on the
screen. To draw a line, click the left mouse button where you want to start it,
then hold down the button and drag the mouse to the finish of the line, where
you should release the button. Once you are sure that the area is completely
enclosed by blue lines, choose the &quot;Fill&quot; button and click inside the area -
it should be filled in. If the entire screen is filled blue, you didn't contain
the area properly. To remove the area, choose the &quot;Wipe colour&quot; mode and then
click on the area. Now, start over again.
<p>
<font color=#00A000><u><b>3.1.2 WALK-BEHIND AREAS</b></u></font><br>
<br>The next job you need to do is to define the walk-behind areas. These areas,
also called &quot;priorities&quot;, tell the game where the character needs to be drawn
behind the background. For example, in the three bottom screens of the demo
game, the player can walk behind the fence.
<br>Choose the &quot;Walk-behind&quot; mode from the left-hand list. You add walk-behind
areas in a very similar way to the walkable areas - in fact, you have the same
three drawing tools.
<br>Once you have finished, you need to define the base-line for the area. This
is a horizontal line which tells the game at what level the character must be
in order to be drawn behind the area. For example, when the man is standing
in front of the street lamp he must be drawn in front; when he is behind it,
he must be drawn behind. Click the &quot;Base-line&quot; button, then click the mouse
on the scene at the base of the walk-behind area. When the character's feet
are below this line, he will be drawn in front of the area; when his feet are
above the line, he will be drawn behind the area.
<br>You may have noticed a window on the screen titled &quot;Editing colour&quot;. By
default, you have been drawing blue walk-behind areas onto the screen. This
is fine for one area, but what if you have two different walk-behind areas on
the screen? They'll need different base-lines, won't they. You can change the
colour you are drawing by clicking the up and down arrows in the &quot;Editing
colour&quot; window. Each colour has its own base-line, which effects the areas
drawn in that colour.
<p>
<font color=#00A000><u><b>3.1.3 TRYING OUT YOUR GAME</b></u></font><br>
<br>Now that you have a semi-complete first room, it would be a good time to test
it out. Go back to the &quot;Setup screen&quot; mode and click &quot;Save room...&quot;. This
will save your work to disk. In the file selector, click near the top on the
line which displays the current directory, then type in the name you want to
give the room file. The game uses files called ROOMx.CRM, where x is the room
number, and the player starts in room 1, so type ROOM1 and press the OK
button.
<br>Now, go to the &quot;Game&quot; tab (bottom of the screen), and click the &quot;Save game&quot;
button. This will create all the files necessary to run the game. Click
the &quot;Quit&quot; button to exit the editor. Your game is created as an EXE file
with the name you entered at the very beginning. For example, if you typed
MYGAME as the name for the new game, it will be MYGAME.EXE. Run this to test
your game.
<br>You should see your first screen, with the man on it. Walk around the screen,
checking out any walk-behind areas you added. If the man won't move anywhere,
he probably hasn't started on a walkable area and therefore can't move.
Press Ctrl-Q to exit the engine, then load up the Room Editor again. Choose
the &quot;Load room...&quot; button and load in the ROOM1 you saved earlier.
(If you need to change where the man starts, choose the &quot;Visual&quot; tab, then
the &quot;Characters&quot; sub-mode, then click on the &quot;AT 260,190&quot; button on the right
hand side of the screen. Here you can type in the co-ordinates for where you
want the man to start. To get the co-ordinates, use the &quot;Ask position&quot;
function in the Rooms, Setup screen mode).
<br>Whenever you want to test your game, ALWAYS save the room you were working on,
and then save the game before exiting the editor.
<p>
<font color=#00A000><u><b>3.1.4 HOTSPOTS</b></u></font><br>
<br>Your room is now almost complete - except for one thing, interactivity. As it
is, the player can't look at anything, talk to anything, or do anything.
A hotspot is an area of the screen where the game will react if the player
clicks the mouse there. For example, a wall could be a hotspot, a fence could
be a hotspot, and so on - in fact, every part of the screen can be one hotspot
or another.
<br>Choose the &quot;Hotspots&quot; sub-mode from the Rooms tab. As with the walkable areas
and walk-behind areas, you draw hotspots using the standard three drawing
modes. The different colours this time represent the different game reactions:
the player clicking on a hotspot 1 area will cause a certain response;
clicking on a hotspot 2 area will cause a different response.
<br>Once you have drawn the hotspots on, you need to define what happens when the
player interacts with them. You do this one hotspot at a time. Use the up and
down arrow buttons to make sure that colour 1 (dark blue) is the current
hotspot. Now, click the &quot;Interaction&quot; button.
<br><font color=#00A000><u><b>3.1.4.1 INTERACTIONS</b></u></font><br>
<br>The interaction window is split up into two parts: the bottom part lists all
the available events on the hotspot which you can add a reaction for. The top
part shows the reactions you have added. To start with, the top window is
empty. To respond to an event, click on the event's name in the bottom window.
For example, we want to display a message when the player LOOKs at our
hotspot 1. So, click &quot;Look at hotspot&quot; on the bottom list. It will be added
to the top list, along with three other columns - Score, Command and Data.
The Score column allows you to give the player points when the event occurs,
and note that this will only happen the first time they do it, so they can't
keep getting more and more points. We don't want to give our player a score
for just looking though, so we'll leave it as 0.
<br>The Data column is used to provide additional information to certain commands;
otherwise you can just leave it as 0.
<br>The Command column defines what happens when the event occurs (in this case,
when the player looks at our hotspot). Click on the &quot;(Do nothing)&quot; and a menu
appears, with all the possible responses to the event. What these all mean
is listed in section 6.2. We just want to display a message though, so
click the &quot;Display message %d&quot; option. The &quot;%d&quot; simply means that you will
have to type in a number to replace it - in this case, the message number.
On clicking, a window pops up asking you for the message number you want to
display. (We can't just type the message in there and then; we'll do it in a
second). Since this will be our first message, and since message numbering
starts at 0, type in 0 and press return.
<br><font color=#00A000><u><b>3.1.4.2 MESSAGES</b></u></font><br>
<br>Each room has its own set of messages. These are the strings that can be
displayed during the game. Choose the &quot;Message editor&quot; button at the bottom
of the interaction window. The screen will switch to text-mode and you will
see displayed &quot;No messages&quot;. To create one, press A. Now, press enter to
edit it. Type in a message appropriate to your hotspot, for example,
<br>This is a brick wall. Nothing more exciting than that.
<br>and press return.
<br>Note that pressing F2 toggles &quot;Display next message&quot; on and off. When this
is on, the next message will be displayed after the player has clicked to
remove this one. This feature is useful for conversations and long
<br>descriptions. We won't use it now, however, so leave it set to &quot;No&quot;.
Now hit ESC to leave the message editor. Click OK to exit the interaction
window.
<br><font color=#00A000><u><b>3.1.4.3 WALK-TO SPOTS</b></u></font><br>
<br>You may have noticed on the Hotspots screen, a button called &quot;Walk-to&quot;. This
allows you to set a position for each hotspot where the character will walk to
whenever the player interacts with the hotspot. This is like the way the
Lucasarts games like Monkey Island (tm) work. If you set a walk-to point, then
whenever the player clicks interact or talk on the hotspot, the main character
will first walk to that point before the relevant event is triggered.
<br>If you want, the man can also walk there when the LOOK mode is used - this
option is configurable in the Game tab, &quot;Main&quot; sub-mode.
<p>
<font color=#00A000><u><b>3.1.5 SCREEN EDGES</b></u></font><br>
<br>Each room has four &quot;edges&quot;. The edges define how near to the side of the
screen the player needs to go for him to be considered to have left the
screen. More precisely, when the man passes an edge he triggers the related
event in the room interaction screen.
<br>Edges are the usual way that room changes take place - when the man walks off
an edge, the game responds with a &quot;Go to screen&quot; command to send him to a new
location.
<br>To view the edges, go to the Room tab, &quot;Setup screen&quot; sub-mode, then click
the &quot;Edges&quot; button. The four edges will be displayed as yellow lines on top
of the background. To move an edge, click the left button on it and drag the
mouse.
<br>To set what happens when the character walks off an edge, click the
<br>&quot;Interaction&quot; button on the &quot;Setup screen&quot; tab. This contains four events,
called &quot;Walk off top&quot;, &quot;Walk off bottom&quot;, and so on, which are triggered when
the man passes the relevant edge. This interaction window also contains some
other useful room events.
<p>
<font color=#00A000><u><b>3.1.6 OBJECTS</b></u></font><br>
<br>Objects, also known as &quot;sprites&quot;, are images on the screen which, unlike the
screen background, can move, change and disappear. You use objects for things
which the player can take (so they disappear) and for things on the screen
which you want to animate.
<br>As as example, let's say you want to have a key on the floor of your room
which the player can take. Go to the Rooms tab, &quot;Objects&quot; sub-mode. Now, click
the &quot;New object&quot; button. You now click onto the screen where you want the
object to be added. Don't worry if you don't get its position right, you can
move it later. The object will be added as a blue cup.
<br>The first thing we want to do is change the look of the object - obviously, we
want a picture of a key. Click on the picture of the cup near the bottom-right
corner of the screen. When you do, you will be presented with a screen which
shows all the sprite graphics available. There is a picture of a key on the
top row, so click on that. (You can add your own graphics to this list; we
will describe how to do that later).
<br>If you want to move the object, click the &quot;Move objects&quot; button. Then, click
and drag the left button on the object to move it.
<br>Lastly, we need to define what happens when the player interacts with the
object. Click the &quot;Interaction&quot; button. This is almost identical to the way
it worked with the hotspots (see section 3.1.4.1).
<br>You may have noticed a couple of other buttons on the Objects screen, called
&quot;Base-line&quot; and &quot;Object is on&quot;. Normally, the base-line for an object is at
the base of the object (the baseline is used for front-to-back ordered drawing
of the graphics). However, in some cases you may want to override this - for
example, if a poster is lying flat on the ground, you wouldn't want the man to
walk behind it. You can override the baseline for an object by clicking the
&quot;base-line&quot; button and clicking on where you want the base to be (near the top
of the screen would solve our poster problem).
<br>Normally, you want the objects to be visible on the screen to begin with.
However, in some situations you may not want the object to appear until later
on in the game. To have the object start the game &quot;off&quot;, click the &quot;Object is
on&quot; button to toggle it. You can switch the object on in the game using the
&quot;Turn on object&quot; command.
<br>NOTE: The game's speed is directly related to the number of objects on the
screen. Although you probably won't notice it on a Pentium, a room with 10
objects will noticeably slow down on a 486.
<p>
Now, we have a fully-working first room. Follow the procedures we did in
section 3.1.3 to try it out.
<p>
<font color=#00A000><u><b>3.1.7 ROOM OPTIONS</b></u></font><br>
<br>In the &quot;Setup screen&quot; mode, you can set a few room options by clicking the
&quot;Options&quot; button. This screen allows you to configure some room-specific
things. To change an option, left-click it.<ul>
<li>Play music on room load - if set, then the background music will be
changed to the music you specify here. See section 4.1 for information
on the music and sound support in AGS.</li>
<li>Main character visible - normally TRUE, if you set this to FALSE then
the main character will not be visible on this screen. This is useful for
close-up control panels, and cutscenes which the main character is not
part of.</li>
<li>Main character view - allows you to change the main character's view
number for this screen only. This is useful if you want, for example, an
overhead map screen, so the character should have a birdseye-type view.
The character's view is set back to normal when they leave the screen.</li>
<li>Music volume - allows you to change the volume of the background music
for this screen. For example, as the player approaches a bar, on successive
screens the music could get louder.</li>
</ul>
<br><font color=#00A000><u><b>3.2 EDITING GAME SETTINGS</b></u></font><br>
<br>Now that you know how to create a room, it's time to set up the game-wide
settings. These include inventory objects, global messages, palette setup
and other things which do not depend on individual rooms.
<p>
<font color=#00A000><u><b>3.2.1 PALETTE SETUP</b></u></font><br>
<br>The first thing you need to do when you create a new game is to decide whether
you want to use 8-bit (palette-based) colour or 16-bit (hi-colour).
<br>If you want to use 16-bit colour, then go to the Game tab, &quot;Palette&quot; mode,
and click the &quot;Make game hi-color&quot; button. This will convert your game to
use hi-colour from now on. You can still use 256-colour backgrounds and
sprites if you want to, but the engine will only run in a 16-bit colour
resolution, thus slowing it down. See section 3.2.11 below for more info on
the hi-colour option.
<br>If you want to use 8-bit (because it runs faster), you need to set up the
palette. This is because all sprite and background scene imports rely on the
palette setup to be the same.
<br>Choose the Game tab, &quot;Palette&quot; sub-mode. Here you will see the 256-colour
palette displayed in a grid. Most of the slots are marked &quot;X&quot; - these are the
slots reserved for the background pictures, and will be different in each
room. The other colours will be as they look here for the entire game. These
fixed colours allow things like the main character graphics, which must be
displayed on more than one screen, to work.
<br>If you want, you can assign more or less colours to the backgrounds. To toggle
the background assignment on/off, click on the slot, then click the button
&quot;background&quot; (or &quot;un-background&quot;) to swap the slot's status.
IMPORTANT NOTE: You must set up the palette as you want it before you start
making your game - if you change it later, you will have to re-import all the
sprites and background scenes.
<br>You can select multiple colour slots by clicking on the first slot, then
shift-clicking on the last slot in the range you want to select. You can then
toggle the background status of all the selected slots at once.
<br>The &quot;Export pal&quot; button exports the entire palette to a .PAL or PCX file which
you can then use to read back into the Editor in a different game. If you
choose to export to a pcx file, then a screen shot of the Palette Editor will
be saved as the picture. This way you can see all the game-wide colours in
the file.
<br>The &quot;Import pal&quot; button replaces the selected palette entries with those
entries from the PAL or PCX file you choose. It can read standard 768-byte
PAL files, SCI palette resources (renamed to extension .pal) and JASC PSP
palette files.
<p>
<font color=#00A000><u><b>3.2.2 INVENTORY</b></u></font><br>
<br>Most adventure games allow the player to carry a set of objects, which he can
then use to solve puzzles. Adventure Game Studio makes this inventory easy
for you to manage.
<br>Every inventory item which the player may carry during the game at one time
or another is listed under the Game tab, &quot;Inventory&quot; sub-mode. Here, each item
also has a number which you use in interactions to identify the object.
The left hand side of the screen lists all the items in the game.  On the
right is the graphic used for the object in the inventory window. To change
this, left-click the picture, then select the new graphic from the dialog
which appears.
<br>To change the object's name, click the button marked &quot;Name&quot; in the bottom part
of the screen. If you want the player to start the game with this item in his
inventory, check the &quot;Player starts with this item&quot; check-box.
To create a new item, click the &quot;New item...&quot; button. You will be asked for
the new item's name, and then it will be assigned the next available number.
The last thing to do with the inventory items is to define their interactions:
what happens when the player manipulates them in the inventory window. Click
the &quot;Interaction&quot; button, which brings up a window which works identically
to the hotspot interactions (section 3.1.4.1). The available events are
described in the reference section 6.1.4.
<br>NOTE: Several limitations apply to the commands you can use in the Inventory
interactions. This is because they must run from all rooms, and so cannot
have any room-specific commands. In particular, you cannot use the &quot;Run
animation&quot; or &quot;Run graphical script&quot; commands, and if you use a &quot;Display
message&quot; command, then it must display a global message (see section 3.2.4,
below).
<br>To give the item to the player during the game, you use the &quot;Add inventory&quot;
or &quot;Remove obj, add inv&quot; commands. The inventory number required by these
commands is the item number from the list described above.
<br>NOTE: Each character in the game carries their own set of inventory items.
This means, if you want to create a game like Day of the Tentacle, where the
player can control three different characters, each character will have a
seperate inventory. All inventory commands always operate on the *current
player character*.
<br>You have two choices about how the inventory is displayed to the player.
Unfortunately, due to the way the inventory works, the two options are
built-in to the engine and are not customizable.
<br>The default option is the Sierra-style pop-up inventory window, which is
popped up by clicking on the Bag icon on the icon bar (which uses the text
script InventoryScreen function to display it). You can also have the current
inventory item displayed in its own button on the icon bar by creating a
button on the GUI and setting its text to  (INV)  which stretches the item
picture to the button size, or  (INVNS)  which draws the inventory item
picture straight onto the button with no resizing.
<br>The other option is a Lucasarts-style inventory window. To use this, you
will need to edit the interface to add it, so I will explain this later on.
While you are starting off with AGS, it is recommended to use the supplied
standard Sierra-style inventory window.
<p>
<font color=#00A000><u><b>3.2.3 USING YOUR OWN SPRITE GRAPHICS</b></u></font><br>
<br>When you were choosing the graphics for the object earlier in this tutorial,
you probably noticed that most of the graphics available didn't look up to
much. This is no problem, because you can import your own graphics using
the Sprite Manager.
<br>Go to the Visual tab, &quot;Sprite mgr&quot; sub-mode. Here, you will see the complete
sprite set for the game. There are two ways to import your graphics - either
overwrite an existing slot with your graphic, or create a new slot for it.
The &quot;import&quot; button overwrites the currently selected slot; the &quot;import new&quot;
button will create a new slot for the graphic.
<br>When you click either of these buttons, the file selector appears, where you
can choose a BMP, PCX or GIF file to import. The graphic you choose must be
at the same colour depth as your game (ie. if you are using hi-colour
backgrounds, your sprites must be hi-colour, and vice versa).
<br>The picture is displayed on-screen. The mouse cursor changes to a rectangle,
in which you should enclose the portion of the graphic which you want to
import. You can change the size of the rectangle by clicking the right mouse
button and dragging the mouse. When the rectangle is correctly positioned,
left-click. You can also import the entire picture by pressing Enter.
<br>You may well find that the colours on your graphic look slightly strange in
the Room Editor. This is because the sprites are only allocated, by default,
the first 41 of the palette colours (see the palette section 3.2.1 above), so
your graphic will be remapped to this much smaller palette. If you find that
many of your imported sprites look strange, you can increase the number of
colours assigned to sprites, at the expense of background colours (again see
the section above for information on how to do this).
<br>If your sprite will only be used in one room then alternatively you can
use the &quot;use background palette&quot; option, which will remap your graphic to
the palette of the room currently loaded, giving much better results. Note,
however, that if you do this, and then try and use the sprite on another
screen, its colours will most likely be screwed up. To use the room palette,
check the &quot;use bkgrnd pal&quot; check-box. Make sure to un-check this box before
you import any other sprites.
<br>NOTE: The transparent colour used by AGS is palette index 0 (for 256-colour
sprites) and RGB (255,0,255) for hi-color. Any pixels you draw on imported
sprites in these colours will be transparent.
<p>
You can group imported sprites into folders. This prevents the main sprite
list from becoming very long (and you can only have 120 sprites per folder
anyway). By default, the Sprite Manager displays the Main folder, which
contains some graphics and a sub-folder called &quot;Defaults&quot;. Folders work the
same way as Windows folders (or DOS directories) - they can be nested inside
each other, and in every folder except the main one there is a &quot;parent&quot; link
which will take you back to the folder above.
<br>Note, however, that at present you cannot move sprites between folders so
they are stuck in the folder in which you create them. (Imported sprites
are placed into the currently displayed folder). Also, you cannot delete
sprites or folders.
<p>
AGS now has the ability to import tiled sprites from a single bmp/pcx file.
To do this, draw all the frames of your animation at equal spacings apart
on the source bitmap. Then, when you click &quot;Import&quot; in roomedit and have
selected the file, press &quot;T&quot;. This displays a grid and allows you to position
it correctly over your graphics. Then, click the mouse button and the grid
vanishes, but now you can drag the mouse to resize the grid out to encompass
the sprites you want to import. Once it's the right size, click the mouse
again and they will be imported.
<p>
<font color=#00A000><u><b>3.2.4 GLOBAL MESSAGES</b></u></font><br>
<br>While each room has its own set of messages (&quot;local messages&quot;), in some
situations you need to be able to display a message from more than one room,
or in a global game interaction which is not related to a room. For this
purpose global messages are provided.
<br>Choose the Game tab, &quot;Gl. messages&quot; sub-mode. Here you are presented with
a list of the 500 available global message slots. By default, they are all
empty except messages 996-999 which contain the default messages for actions
on the player character. Global messages are numbered between 500 and 999 so
that they are not confused with local room messages.
<br>To display a global message, simply use its number in any &quot;Display message&quot;
command. If you set the Data column, then the message will be displayed as
speech text from that numbered character (check in the Character editor for
the number of each character). If the Data column is zero, the message is
displayed in the normal dialog box.
<br>You can include a couple of variables into global (and local) messages. You
do this by inserting special tokens into the message. When the message is
displayed in the game, the engine replaces the token with its value:
<br> token   replaced by
<br> @INx@  number of inventory item x that the player has
<br> @GIx@  the current value of GlobalInt x (used with SetGlobalInt/GetGlobalInt)
<p>
<font color=#00A000><u><b>3.2.5 INTRODUCTION SEQUENCES</b></u></font><br>
<br>You can easily add intro, outro and cutscene sequences to your game. There
is no specific function to do these, but using the provided animation and
script commands you can create almost anything you might need.
<br>Normally, the game will start in room 1. However, you can change this to any
room you want. Go to the Visual tab, &quot;Characters&quot; mode. Make sure that the
main character is selected in the list on the left. You will see on the right
hand side &quot;Start in room:&quot; followed by &quot;Room 1&quot;. This is the starting room
for the player character, and it is this entry that decides which is the first
room loaded. If you set it to room 0, then a file named INTRO.CRM will be
used (not ROOM0.CRM as you might think). This is for backward compatibility
with AC 1, but it is also good practice and it is suggested that you use this
feature.
<br>Set the starting room to room 0. Now, when you run the game, the intro will
be the first room loaded. In this room, you will probably want to disable
the main character (if you want a logo graphic up first). Remember, you do
this through  Setup Screen -&gt; Options -&gt; Main character visible.
TIP: The starting room facility is also useful when testing your game - you
can make the game start in any room, at the point where you are testing it,
rather than having to keep playing the game through to get there.
<br>As an example, let's make your logo stay for 5 seconds and then go on to the
next screen. The graphical script's timer functions would be ideal here.
(You may want to read the graphical script documentation, section 3.3.3,
before continuing here).
<br>Choose  Setup Screen -&gt; Interaction. Now, add the &quot;Player enters screen&quot;
event, and set the command to &quot;Run graphical script&quot;. Click the &quot;...&quot; to edit
the script, and add a single command, &quot;Set timer to %d loops&quot;. There are
about 40 loops per second, so replace the %d with 200.
<br>Now, press ESC to exit the graphical script editor. You are back at the
interaction screen. Add the &quot;Repeatedly execute&quot; event. Again, set this to
run a graphical script, and click the &quot;...&quot; button. For this script, we will
need the &quot;If timer expired&quot; command, so drag it in from the left. Remove
the &quot;Display message&quot; commands which it gives you, and add a &quot;Go to screen&quot;
command under the IF statement. Choose whatever screen number you want. You
could go to screen 1 to start the game, or to another screen to have a longer
introduction sequence. It's up to you.
<p>
<font color=#00A000><u><b>3.2.6 ANIMATIONS</b></u></font><br>
<br>In most games you will use some sort of animation during the game, whether
it be a flag waving in the breeze or the man bending over to pick something
up. The term &quot;animation&quot; refers to the ability to change the look of, and
move, objects.
<br>Animations in AGS are managed using Views. A &quot;view&quot; is a set of one or more
&quot;loops&quot;. A loop is a set of frames which, when put together, give the effect
of movement. Each frame in the view can be set a graphic and a speed.
<br>Go to the Visual tab, &quot;Views&quot; sub-mode. This is the View Editor. Here you will
see the main character's walking view.
<br>Click the &quot;New view&quot; button to create us a new, empty view. Now, click the
down arrow button until the currently displayed view shows our newly created
one.
<br>Each loop is displayed horizontally with its number at the left hand side,
frames going out to the right. To add a frame, click the grey &quot;New frame&quot;
button. To delete a frame, right-click it.
<br>To change a frame's graphic, double-left-click it. The sprite list screen
will be displayed (you may remember this from the Object graphic selection)
where you can choose the graphic you want to use for this frame.
<br>Above each frame you will see &quot;SPD:0&quot;. This is the frame's *relative* speed,
which you can change by clicking on the word &quot;SPD:&quot;. The larger the number,
the longer the frame stays (ie. the slower it is). When the animation is run,
an overall animation speed will be set, so the actual speed of the frame
will be:  overall_speed + frame_speed  . Note that you can use negative
numbers for the frame speed to make it particularly fast, for example setting
it to -3 means that the frame will stay for hardly any time at all.
<br>You run an animation by using the &quot;Run animation&quot; interaction command or the
text script animation commands. If you use the &quot;Run animation&quot; interaction
command, you then click the &quot;...&quot; button to edit the animation. The animation
editor is very similar to the graphical script editor (see section 3.3.3),
but it has different commands available.
<br>To animate an object, you first of all need to set the object's view to the
correct view number (use the &quot;Set object view&quot; animation command or the
SetObjectView text script command), and then use the &quot;Animate using loop&quot;
animation command or the AnimateObject text script command to actually start
the animation. The Animation Editor commands are described in section 6.8.
<p>
<font color=#00A000><u><b>3.2.7 CHARACTERS</b></u></font><br>
<br>Adventure Game Studio makes it easy to add your own non-player characters
into the game. A character is similar to an object, except that it can change
rooms, maintain its own inventory, and take part in conversations (more on
these later). It can also have its own custom animation speed and movement
speed.
<br>Go to the &quot;Visual&quot; tab, &quot;Characters&quot; mode. You will see on the left of the
screen a list of all the characters in the game, with &quot;NEW CHARACTER&quot; at the
end of it. To create a new character, select &quot;NEW CHARACTER&quot; from the list,
then click the &quot;NAME&quot; button in the bottom part of the screen to change its
name to whatever you want to call your character. By doing this, a new
character slot is created.
<br>You will see that there are a lot of options which you can set for each
character. First of all, the &quot;This is the player character&quot; check-box allows
you to change which character the player will control at the start of the
game. When the game starts, the first room loaded will be this character's
starting room. By checking this box for one character, it will be de-selected
for any other character which was previously set.
<br>Secondly, the &quot;Ignore scaling&quot; check-box allows you to specify that this
character will not be stretched or shrunk in scaling areas of the screen. This
could be useful if you have a character who always stands still in the same
place, and you want the graphics on-screen to be the same size as you drew
them, even though he is standing on a scaling area.
<br>The &quot;No interaction&quot; check-box tells AGS that you want the character to be
invisible to all the interaction parts of the game. This is like the way the
main character works in Lucasarts games - if you move the cursor over him
or click to look, speak, etc, then the game will ignore the character and
respond to whatever is behind him.
<br>To set which room this character starts in, click the &quot;Room 1&quot; button on the
right hand side of the screen, and type in the new room you want him to start
in. If you set this to room 0 for the player character, he will start in the
intro screen, INTRO.CRM (see section 3.2.5 for information). You can set the
character's location within this room by clicking the &quot;AT 160,160&quot; box and
typing in the X,Y co-ordinates you want him to start at. These co-ordinates
should be the middle of his feet. (You can find out the co-ordinates of a
screen point using the &quot;Ask position&quot; option in the Rooms, Setup Screen tab).
<br>The &quot;Default view&quot; is where you set what the character looks like. You must
create a view in the View Editor (described in section 3.2.6, above), and this
view must have either 4 or 8 loops. If you use 4 loops, then when walking
diagonally the closest straight direction is used for the graphics. Each loop
is used for the character walking in one direction, as follows:
<br> Loop 0 - walking down (towards screen)
<br> Loop 1 - walking left
<br> Loop 2 - walking right
<br> Loop 3 - walking up (away from screen)
<br> Loop 4 - walking diagonally down-right
<br> Loop 5 - walking diagonally up-right
<br> Loop 6 - walking diagonally down-left
<br> Loop 7 - walking diagonally up-left
<br>Once you set this option, you should see a preview of the character walking
around in the top part of the screen.
<br>To change the rate at which the character animates, click the &quot;Anim spd&quot;
option. Here, a smaller number means faster animation. Note that this does NOT
effect the speed at which the character actually moves when walking.
<br>The &quot;Move spd&quot; option allows you to control how fast the character moves when
walking. Here, a larger number means he walks faster.
<br>The &quot;Talk clr&quot; option on the right of the screen specifies which colour is
used for the text when this character is talking. It effects both messages
displayed with &quot;Display message&quot; commands which are set to that character,
and also conversations. You can find out the colour for each number by going
to the Game tab, &quot;Palette&quot; mode.
<br>The &quot;Idle view&quot; button allows you to set an idle animation for the character.
To do this, create a new view, with one or more loops of the character idle
(eg. smoking, reading a book, etc). Then, click &quot;No idle view&quot; and type in
the view number. If the player stands still for 20 seconds (you can change
the timeout with the SetCharacterIdle text script function), then a random
loop from the view will be played.
<br>In the very bottom-right of the screen is a button called &quot;Script Name&quot;. This
sets the name which the character will be referred to by in text scripts and
in conversation scripting. The difference from the main Name of the character
is that the script name may only contain letters A-Z.
<br>To set what happens when the player interacts with the character, click the
&quot;Interaction&quot; button. You will be presented with the (by now familiar)
interaction window. NOTE that, as with Inventory interactions, you may NOT
use the &quot;Run animation&quot; or &quot;Run graphical script&quot; commands, or display a local
message. Basically, you need to display global messages or use text scripts
to handle character interactions.
<br>You can also set a talking view for the character. To set one, click the
button beside where it says &quot;Talking view:&quot;. If you set a talking view, then
that view will be used to animate the character while they are speaking. You
should generally have about 2-3 frames in each loop (the loops are used for
the same directions as in the main view).
<br>New in v2.05 is support for exporting your characters. What this means is that
you can export a character to a file, and then import the file into a
<br>different game - so you can share the same main character between games, or
create one for distribution on the internet. When you click the &quot;Export char&quot;
button, you will be asked what you want to call the file, so type a short
name and press ok. The entire character setup, and graphics, will be exported
to the file. This includes the character's walking and talking graphics.
Then, in RoomEdit (with any game loaded), press the &quot;I&quot; key. The file selector
appears, where you should find the CHA file which you exported earlier. A
new character slot will be created and all the settings imported.
<br>NOTE: Because importing always creates a new slot, you cannot use it to
overwrite an existing character.
<p>
<font color=#00A000><u><b>3.2.8 CONVERSATIONS</b></u></font><br>
<br>While the old Sierra games were mainly based on action and not talking, the
Lucasarts games took the opposite approach.
<br>If you want to create a game with conversations where the player can choose
from a list of optional topics to talk about, you can now with the new Dialog
Editor. Go to the &quot;Advanced&quot; tab, Dialog mode.
<br>Conversations are made up of Topics. A &quot;topic&quot; is a list of choices from
which the player can choose. You may have up to 14 choices in a topic.
However, not all of them need be available to the player at the start of the
game - you can enable various options for conversation once the player has
said or done other things. For example, when you talk to the man in the demo
game, the first option is just &quot;Hi&quot;. Once he has said this, however, a new
option becomes available.
<br>The Dialog Editor is quite self-explanitory - you view one topic at a time,
using the up/down arrow buttons to choose the current topic. Then, you see
the list of options for the topic in the top part of the screen. Each option
has a &quot;Yes&quot; or &quot;No&quot; on the right hand side, which specifies whether that
option is available to the player at the start of the game.
<br>There is also a column headed &quot;Say&quot; - this defines whether the character
says the option when the player clicks it. The default is on, but if you
want options describing the player's actions rather than the actual words,
you may want to turn this column off for that dialog.
<br>You control what happens when the player chooses an option by clicking the
&quot;Edit script&quot; button. This is NOT the same script language as the main text
scripts use - it is a much simplified and easier to understand language
specific to dialogs.
<br>Each topic has its own script file. When you click &quot;Edit script&quot; for the
first time on a topic, all you will see is a number of lines starting with
an '@' symbol. In the dialog script, these signify the starting points of
the script for each option. For example, when the player clicks on option 3,
the script will begin on the line following &quot;@3&quot;. There is also a special
starting point, called &quot;@S&quot;. This is run when the conversation starts, before
any choices are given to the player. This could be used to display a &quot;Hello&quot;
message or something similar.
<br>To display some speech, you begin the line with the character's SCRIPT NAME
(not full name), followed by a colon, then a space, and then what you want
them to say. For example, if my main character's script name is EGO, I would
write
<br>ego: &quot;I am very happy today because it's my birthday.&quot;
<br>The character name is used by the system to choose the correct colour for
the text. You can have as many lines of speech like this as you want within
the script. You can also use the special character name &quot;narrator&quot;, which
displays the text in the pop-up message box instead of as speech text.
To signal the end of the script for this option, place a &quot;return&quot; command on
the last line of it. For example,
<br>@1
<br>ego: &quot;Hello. How are you?&quot;
<br>narrator: The man looks you in the eye.
<br>otherman: &quot;I'm fine.&quot;
<br>return
<br>This tells the program to go back and display the choices again to the player.
If you use &quot;stop&quot; instead of return, then the conversation is ended. You use
this after the player saying &quot;Goodbye&quot; or something similar.
The dialog commands available are:
<br>add-inv X
<br>  Adds inventory item X to the current player's inventory. This does the
<br>  same thing as the AddInventory text script command, but is provided here
<br>  because it is frequently used in dialogs.
<br>goto-dialog X
<br>  Switches the current topic to Topic X, and displays the current list of
<br>  choices for that topic.
<br>new-room X
<br>  Takes the player to room X, and aborts the conversation. Since this does
<br>  not allow you to specify co-ordinates, you may need to use some Player
<br>  Enters Screen logic in the target screen to place the character properly.
option-off X
<br>  Turns option X for the current topic off, meaning it won't be displayed in
<br>  the list of choices next time.
<br>option-off-forever X
<br>  Turns option X off permanently. It will never again be displayed, not even
<br>  if an &quot;option-on&quot; command is used.
<br>option-on X
<br>  Turns option X for the current topic on, including it in the list of choices
<br>  to the player next time they are displayed.
<br>play-sound X
<br>  Plays sound effect SoundX.wav or SoundX.voc. You can use this to add speech
<br>  to your game.
<br>return
<br>  Stops the script and returns to the list of choices.
<br>run-script X
<br>  Runs global text script function &quot;dialog_request&quot;, with X passed as the
<br>  single parameter. This allows you to do more advanced things in a dialog,
<br>  such as adding an inventory item and so on. The &quot;dialog_request&quot; function
<br>  should be placed in your game's global script file, as follows:
<br>    function dialog_request (int xvalue) {
<br>      // your code here
<br>      }
<br>set-speech-view NAME X
<br>  Changes character NAME's talking view to X. NAME must be their script name,
<br>  and X is the number of the new talking view.
<br>  Use this to easily change their facial expression during a conversation.
stop
<br>  Stops the conversation and returns the player to the game.
<br>For an example of a dialog script, load the demo game into RoomEdit and
look at the script for its topic 0.
<p>
<font color=#00A000><u><b>3.2.9 GAME OPTIONS</b></u></font><br>
<br>On the Game, Misc tab you may have noticed some check-boxes in the top half
of the screen. These set gamewide options, and mean the following things.
Note that some things listed here are explained later in the documentation,
so if you don't understand one of the items in this list, come back to it
later:<ul>
<li>Debug Mode - whether the debug keys are active. When debug mode is on,
you can press Ctrl-X to teleport to any room, Ctrl-S to give all inventory
items, Ctrl-A to display walls on the screen, and Ctrl-D to display
<br>statistics about the current room. When debug mode is off, these do nothing.
(More specifically, the text script Debug() function is disabled).</li>
<li>Play sound on score - controls whether a sound effect is played when
the player scores points. If so, you can set the sound number, which will
play SOUNDx.WAV (or SOUNDx.VOC), where X is the number you set.</li>
<li>Walk to hotspot in Look mode - controls whether the player will walk
to &quot;walk-to&quot; spots when the player looks at the hotspot. Normally he only
walks on use, speak and use-inv. See section 3.1.4.3 for information.</li>
<li>Conversation on GUI - controls where the player's options for dialog are
displayed. If this option is not checked, then in a conversation, the options
will be displayed at the bottom of the screen. If you check this box, then
instead the options will be displayed on the GUI you specify.</li>
<li>Use &quot;anti-glide&quot; mode - you may notice that, as the character walks, it
can seem as if he is gliding, especially if you have a slow animation speed
setting. When anti-glide mode is on, the man's position is only updated
when the frame of animation changes. You will need to increase each
character's walking speed if you use this option.</li>
<li>Text windows use GUI - allows you to customize the standard text window
appearance in the game, using the specified interface element. See section
<font color=#00A000><u><b>4.2.3 for more information.</li></b></u></font><br>
<li>Pixel gap between options - defines the gap between the options displayed
to the player in a conversation. Normally this is 0, which means the
<br>options are right below each other. Changing it to 1 or 2 can make the
option display look less cluttered; it's a matter of personal preference.</li>
<li>Player can't skip speech text - prevents the player clicking the mouse
to skip conversation text. They can still use the ESC key to skip the text,
however.</li>
<li>Buttons off when disabled - specifies that, when an interface button is
disabled, then it is simply not displayed at all. The default action is to
&quot;grey-out&quot; the button by putting alternating black pixels on it.</li>
<li>Always display as speech - if you select this option, then all normal
text in the game will be displayed above the main character's head as speech
text, much like the way the Lucasarts games worked. If this option is not
checked, then normal text appears in a pop-up message box, like the way that
the Sierra games worked.</li>
<li>Use Sierra-style speech window - normally, when a character talks, the
speech text is displayed above their head in the game, and the character's
talking view is used to animate the actual character. However, if you set
this option then the talking view is used to display an animating graphic
seperately in the top-left of the screen, with the text on the right of it.
This is similar to the way that Space Quest 5, King's Quest 6 and other
later Sierra games worked. You can also cycle to another option, &quot;Sierra-
style with background&quot;, which is the same except a text window is drawn
behind the speech text to make it easier to read.</li>
<li>Pixel-perfect click detection - normally, when the player clicks the
mouse, AGS just checks to see if the cursor is within the rectangular area
of each character and object on the screen. However, if this option is
checked, then it will further check whether the player clicked on an actual
pixel of the object graphic, or whether it was a transparent part of the
graphic. If this option is enabled and they click on a transparent pixel,
then the hotspot behind the object will be activated instead.
<br>NOTE: This option does not currently work correctly with scaled characters.</li>
<li>No special walk-mode processing - normally, when you click the mouse in
the Walk mode, the main character will move to where you clicked. However,
if you want to create a game all viewed from a 1st-person perspective, and
so don't have a main character, then selecting this option allows you to
use the Walk mode for other things. If selected, then &quot;Character stands on
hotspot&quot; events are instead triggered by clicking the Walk cursor on the
hotspot.</li>
<li>Use 320x240 letter-box mode - normally, the available screen resolutions
are 320x200 and 640x400; however, if you select this mode then 320x240 and
<br> 640x480 will be used instead. The screeen will be &quot;letter-boxed&quot; - that is,
there will be a black border top and bottom. You may want to use this option
if you need a square pixel aspect ratio for your graphics.
<br>When this option is enabled, any 640x480 rooms you have will be expanded
to full-screen instead of scrolling.</li>
<li>Don't modify inventory cursor - normally, when you select an inventory
item the mouse cursor is changed into that item. However, if you want to
create a Lucasarts-style game (where the inventory cursor is always a
cross-hair), check this option and it won't be changed.</li>
<li>Don't automatically lose inventory - normally, when a &quot;Use inventory&quot;
interaction is run (and Data is not 99), the player loses the inventory
item. However, if you set this option then they will NEVER lose any
inventory items automatically - you must specifically use a &quot;Lose inventory&quot;
command when you want them to lose it.</li>
<li>Don't scale up fonts - normally, if the player chooses 640x400, then
the fonts will be scaled up to match. However, if you have drawn your fonts
for the 640x400 resolution, use this option to stop them being stretched.</li>
<li>Split resource files - see section 4.3.2 for information.</li>
<li>Characters turn before walking - specifies that when a character starts
to walk somewhere, it will first turn round to face the correct direction
using available animation frames, rather than just suddenly switching to
face the right way.</li>
</ul>
<br><font color=#00A000><u><b>3.2.10 FONTS</b></u></font><br>
<br>Adventure Game Studio allows you to replace the default font and to add your
own. This feature is currently very limited in that you can only import SCI
fonts (Sierra's font format). These can be created in two ways:
<br> (a) Extract the font from a Sierra game, using the SCI Decoder program
<br>     available on the internet.
<br> (b) Create your own font and save it in SCI Font format, using the SCI
<br>     Graphic Studio program  (http://scigraphicstudio.cjb.net).
<br>Go to the &quot;Visual&quot; tab, &quot;Fonts&quot; mode. Here you can see all the current fonts
by using the arrow buttons to cycle through them. You can create a new font
slot by clicking the &quot;New font&quot; button. To import your SCI Font into the
current slot, click the &quot;Import SCI font&quot; button.
<br>IMPORTANT: The fonts which will be used for speech should generally also have
an outline font. You can see this with the default fonts, font 1 is the speech
font, which is drawn in the character's colour, and font 2 is the outline font,
which is drawn in black behind the speech in the game. This helps avoid any
colour clashes between the font and the background.
<br>To set a font to have an outline font, select the main (coloured) font as the
current font, then click the &quot;No outline&quot; button. You will be prompted for
the font number of the outline font, so type it in.
<br>NOTE: Font 0 is used as the normal text font, and font 1 is used as the
speech font. Therefore any extra fonts you add cannot be used.
<p>
<font color=#00A000><u><b>3.2.11 HI-COLOUR NOTES</b></u></font><br>
<br>AGS now supports 16-bit hi-colour graphics. In order to use this feature,
go to the Game tab, &quot;Palette&quot; mode and click the &quot;Make game hi-color&quot; button.
Acknowledge the warning and your game is converted. You won't see any change
at first - in fact, the only difference made is that it now allows you to
import 16-bit backgrounds and sprites, and that the engine will select a
<br> 16-bit colour display mode. This means that to play your game the player MUST
have a Super-VGA card - standard VGA cannot display hi-colour. They will
also need to make sure they have all their VESA drivers correctly installed.
RoomEdit now switches to 320x200 16-bit colour, so all your backgrounds and
sprites should look as they will in the game.
<br>Because hi-colour support is new to AGS, you may notice bugs with it in
various places in roomedit - for example, sprites showing up funny in various
modes. Don't worry though - it'll all look right when you run the game.
If you select the 640x400 video mode, and run a hi-colour game, you'll notice
that the engine is using letterboxing even if you didn't want to. This is
because there is no 640x400x16 video mode, so the engine has to use 640x480
and put black borders on the top and bottom. Sorry, no way round this.
<p>
<font color=#00A000><u><b>3.3 OTHER ROOM FEATURES</b></u></font><br>
<br>This section describes slightly more advanced things you can do with the
rooms.
<br><font color=#00A000><u><b>3.3.1 CHARACTER SCALING</b></u></font><br>
<br>AGS supports scaling of characters, where the character can appear to get
smaller as he walks away from the screen. Character scaling is supported as
part of the walkable areas in a room.
<br>The reason why you have multiple colours available for the walkable areas is
because you can set a zoom level for each colour, which defines how large
the character will be while he is in that area. The default for all walkable
areas is 100%, ie. full size. However, you can adjust it using the &quot;Walkable
Areas&quot; mode to anywhere from 10% (one-tenth size) to 200% (double size).
<br>The scaling settings effect all CHARACTERS in the game, but not objects. You
can disable the scaling for an individual character by checking the &quot;ignore
scaling&quot; box in that character's properties.
<p>
<font color=#00A000><u><b>3.3.2 SCROLLING</b></u></font><br>
<br>If you've been wondering, I'll tell you now: Yes, you can create scrolling
rooms, like the ones used in Lucasarts games like Monkey Island (tm) and Day
of the Tentacle.
<br>To create a scrolling room, just import a scene that is larger than 320x200.
For example, 500x200 is a good size for Lucasarts-type rooms.
<br>When you import the scene, a message box will appear asking you what
<br>resolution the picture is drawn for - this is because the picture could
either be a scrolling room at 320x200, or a single non-scrolling screen at
640x400. So,  with a 500x200 room you would click the &quot;320x200&quot; button.
That's all you have to do. Draw on the walkable areas, hotspots and so on, as
normal, and then save the room. The screen will follow the main character
around.
<br>TIP: You can also have scrolling hi-res rooms. Just import a scene which is
larger than 640x400.
<p>
<font color=#00A000><u><b>3.3.3 GRAPHICAL SCRIPTS</b></u></font><br>
<br>NOTE: the graphical script system is currently depreciated awaiting a total
rewrite. Currently you are advised to use the text script system instead, for
which tutorials and help are provided on the website and forums.
<br>(old text follows):
<br>While AGS provides a comprehensive text scripting system, there are some
occasions when it is easier and neater to use a graphical script. Also, if
you are new to scripting, the graphical script is the best way to learn.
A graphical script is the easiest way to add several responses to an event.
Normally, when an event occurs, you can only set one reaction using the
Interaction window, which limits your possibilities. But, by using a graphical
script, you can do much more complex things.
<br>At its simplest, a graphical script is just a list of commands which are
carried out from top to bottom. For example, a &quot;Display message&quot; command
followed by a &quot;Remove object&quot; command. But the graphical script's main power
is in conditional statements - that is, commands which may or may not be
executed, depending on other factors.
<br>To support conditional statements, the graphical script uses flags. Each flag
is either &quot;Set&quot; or &quot;Clear&quot;. All the flags start off clear, and you can set
a flag to the &quot;Set&quot; state to signal that some sort of event has occured.
There are two types of flags - Local flags and Global flags. Local flags are
specific to each room, and you can give the flag a name when you create it.
Global flags are available to every room in the game. They are named GLOBAL1
to GLOBAL50, and changing one of these flags from one room's graphical script
will also change it for all other rooms.
<br>The graphical script editor displays the current script on the left hand
side of the screen, and the list of available commands on the right. When you
start a new script, you will have a single &quot;Display message&quot; command on the
script to the left. To add a new command, drag it from the list on the right
to below the &quot;display message&quot; on the left. You will be asked to type in the
number to replace the %d if the command requires it; this is the same way as
it works in the Interaction windows. To delete a command, drag it over to the
right. You can modify a command's properties by right-clicking it.
<br>When you add conditional (&quot;if&quot;) statements, an indented &quot;display message&quot;
command will be added below it. The indented commands will only be carried out
if the condition is true. For example, consider this script:
<br> Display Message 1              &lt;-- &quot;You turn around to face the key&quot;
<br> If flag GOTKEY is set
<br>   Display Message 2            &lt;-- &quot;But it's gone. You've already taken it&quot;
<br>   Stop Script
<br> Set flag GOTKEY
<br> Display Message 3              &lt;-- &quot;You pick up the key&quot;
<br> Add Inventory 2
<br> Give Score 5
<br>You can create this yourself by dragging the commands over from the right.
The first time the script is run, GOTKEY will be Clear (remember, all flags
start &quot;Clear&quot;), the player will get the key and 5 points, and GOTKEY will
be &quot;Set&quot;. The next time the script is run, instead of getting another key,
the player will be told they already have it, and the script is aborted.
(The &quot;Stop Script&quot; command tells the game not to carry out the rest of the
script).
<br>Commands like &quot;Give score&quot; WILL be carried out every time they are encountered
(in the Interaction windows, the score is only given once), so you must make
sure to use conditional statements so that the player can't keep repeating
the action if you don't want them to.
<br>Descriptions of the special graphical script commands are available in
section 6.7, below.
<p>
<font color=#00A000><u><b>3.3.4 IMPORTING A FILE AS THE WALKABLE AREA MASK</b></u></font><br>
AGS now has the ability to import an external BMP or PCX file to use as the
walkable-area, hotspot or walk-behind area mask. If you don't like the way
you have to draw these in RoomEdit itsself, you can draw them in another
program and then import them. This is also useful if you are converting a
game you were making with another game-creation system into AGS.
<br>To use the feature, click the &quot;IMPORT FILE&quot; button in the relevant mode of
the Room Editor. There are some restrictions to how this file must be drawn:
it must be the exact same size as the background scene (but in the 320x200-
resolution), and it must be in 16-colour (4-bit) or 256-colour (8-bit). Then,
colour 0 on the bitmap signifies transparency and colours 1-15 are used as the
respective hotspot/walk-behind/walkable area numbers. For example, if you have
a 640x400 hi-res background scene, the mask bitmaps must be 320x200 size.
NOTE: Do NOT use any colour numbers above 15 on the mask bitmap. Use only
palette indexes 0 to 15.
<p>
<font color=#00A000><u><b>3.3.5 ANIMATING BACKGROUND SCENES</b></u></font><br>
<br>If you want to have a lot of animation on the screen, you will come across
two problems if you try to do it using objects:
<br>(a) There is a limit of 10 objects per screen, so you may not be able to
<br>  animate everything that you want to.
<br>(b) Objects slow down the game - the more objects on the screen, the slower
<br>  the game runs.
<br>The solution to these problems is to use an animating background scene.
How it works is this: Each room can have from 1 to 5 backgrounds. Normally,
each room just has one background. However, you can import up to four extra
backgrounds in each room, and if you do so then the game will cycle through
them, giving the effect of animation.
<br>This gives two main advantages - you can animate the entire screen, and due
to the way the engine works, it doesn't slow down the game at all.
<br>To import a second background for a room, load the room into RoomEdit, then
go to the Room tab, Setup Screen mode, and click the &quot;Anim bkgrnd&quot; button. A
screen appears, which lists the current backgrounds for the room. To import
a new background, click where it says &quot;None&quot;. To delete a background, click
the &quot;Del&quot; button on the relevant row. That's all there is to it. To leave the
background editor, press any key.
<br>You can adjust the speed of the animation by clicking the &quot;SPD&quot; button, which
is just under the &quot;Anim bkgrnd&quot; button. Smaller number means faster animation,
and the default is 5.
<br>NOTE: All the background scenes must be the same size.
<br>NOTE: All scenes are mapped to the palette of the first scene - this should
not be a problem, but if you use very different colours in the different
frames, you may need to fine-tune the graphics.
<p>
<font color=#00A000><u><b>3.3.6 LIGHTING EFFECTS</b></u></font><br>
<br>New in v2.14 is the ability to use lighting effects on your characters. The
walkable areas tab has a new option in the bottom-right called &quot;Light level&quot;.
By default this reads &quot;Normal&quot;, but by clicking the arrows you can change it
to from -100 to +100. This number is the light level in the current walkable
area: a negative number makes the character darker (-5 is slightly tinted,
down to -100 is very dark), a positive number makes the character lighter (+5
is slightly lighter, +100 is very bright, probably ending up white).
<br>This could be useful if, for example, you have a street lamp on your scene so
when the character walks under it they get brighter, or if a wall is shading
the character from the light they can get darker.
<br>NOTE: Light levels only work when the character's graphic is at the same
colour depth as the background (ie. a 256-colour character in a hi-colour
game won't get lightened).
<br>NOTE: In a 256-colour game, only darkening areas (light level &lt; 0) will work.
Also, depending on the room palette the quality of the darkening will vary
in 256-colour games.
<br>NOTE: Light levels affect characters only - they do not affect objects,
overlays or the background scene.
<p>
<font color=#00A000><u><b>3.3.7 EXACT PALETTE IMPORT</b></u></font><br>
<br>If you have drawn a 256-colour background scene which you want to do palette
effects with (for example using the CyclePalette text script function), you
may find that Roomedit remaps the colours to different slots making it
difficult to do these effects.
<br>To counteract this, RoomEdit now has an &quot;Exact pal import&quot; feature, which
will simply take the palette slots as they are from the source image and
replace the corresponding background slots with them in the room. This means
that your colours will be in the exact slots that you put them in, but you
must make sure that the scene only uses the palette slots that you have
allocated to the background in the Palette editor.
<br>To enable/disable Exact Pal Import mode, press &quot;P&quot; on on the Setup Screen mode
of the editor.
<p>
<font color=#0000A0 size="+1"><u><b>4. Other features</b></u></font><br>
<br><font color=#00A000><u><b>4.1 MUSIC AND SOUND</b></u></font><br>
<br>All good games use sound to involve and immerse the player in the game. AGS
allows you to play a background music track, and also to play sound effects
at appropriate times.
<br>The DOS version of AGS supports Adlib, Sound Blaster and General MIDI for
background music, and it supports the Sound Blaster and ESS Audiodrive for
sound effects.
<br>The Windows version of AGS supports all DirectX-compatible sound cards.
For background music, AGS can use MIDI, MOD, XM, S3M and MP3 music files. For
sound effects, you can use WAV and VOC files.
<br>When AGS needs to play music number X, it will search for the files in the
following order. The first file it finds, it plays: MUSICx.MP3, MUSICx.WAV,
MUSICx,MID, MUSICx.MOD, MUSICx.XM, MUSICx.S3M.
<p>
When the game loads, music 0 will be played if it exists in the game directory.
You can change the music later by setting &quot;Play music on room load&quot; in a room
(see section 3.1.7 for information), by using the PlayMusic text script
command, or by using the &quot;Play sound&quot; interaction command. If you use the
interaction command, you must add 1000 to the music number so that AGS
recognises it as music and not a sound effect. For example, to play music 23,
use &quot;Play sound 1023&quot;.
<br>NOTE: MP3 files are not included in the game EXE, but can be bundled
<br>seperately as a single data file. See section 4.3 for more information.
<p>
To play a sound effect during the game, you can use the PlaySound text script
command, or the &quot;Play sound&quot; interaction command. The game will search for
SOUNDx.WAV and SOUNDx.VOC, where X is the sound number.
<br>Note: The Adlib sound card only supports MIDI music. It cannot play sound
effects, or MOD, XM or MP3 music.
<p>
<font color=#00A000><u><b>4.1.1 VOICE SPEECH</b></u></font><br>
<br>With AGS you can link a line of dialog to a speech file, to enable &quot;talkie&quot;-
style games. Suppose you have a dialog script with the following:
<br>ego: &quot;Hi! How are you?&quot;
<br>david: &quot;I'm fine.&quot;
<br>Normally this would display the words in the speech text above the characters
heads. However, you can add the special character '&amp;' to symbolise that a
voice file should also be played. The file name is made up of the FIRST FOUR
LETTERS of the character's SCRIPT NAME, then an ID number. For example,
ego: &amp;10 &quot;Hi! How are you?&quot;
<br>david: &amp;7 &quot;I'm fine.&quot;
<br>This would play EGO10.WAV with the first line, and DAVI7.WAV with the second.
When a line of text has a voice linked to it, the text on the screen will not
be removed until the voice file has finished playing. If the player interrupts
it by clicking the mouse or pressing a key, the text and voice will be stopped.
<br>NOTE: Currently, only WAV-format files can be used for speech.
<br>If you add or update any voice files, you need to click the &quot;REBUILD VOX FILES&quot;
button in the Main, Game tab of roomedit which will combine them into the
speech file used in the game. This file is called SPEECH.VOX and is seperate
from the rest of your game data so that you can offer it as an optional extra
download to the player. The game will function correctly if the file is not
present.
<br>SeeAlso: SetVoiceMode text script function.
<p>
<font color=#00A000><u><b>4.2 EDITING THE INTERFACE</b></u></font><br>
<br>AGS now supports customizable interfaces. By default, the game interface is
set up to act like Sierra's point-and-click interface of its 1990-93 games.
AGS v2.07 has a completely re-written interface system, now called the GUI
system. (The name change is to help distinguish the new system from the old
system). A description of what's changed from the last version is in
<br>section 4.2.8, below.
<br>To change the interface (recommended for advanced users only), go to the Game
tab, &quot;GUI&quot; mode.
<br>The game interface is split up into GUI &quot;elements&quot;. Each element is a
rectangular region on the screen which is drawn on top of the background
scene. Each element can be set to either:
<br> * be always displayed (for example the Sierra status-line)
<br> * pop-up when the mouse moves to a certain position (eg. Sierra icon-bar)
<br> * pop-up on script command only
<br>The default interface is made up of two elements - the status line, and the
icon bar.
<br>In the GUI Editor, you will see several buttons. The &quot;Export GUI&quot; button
exports the entire interface (ie. all the GUIs, plus button graphics) to a
file, which you can then import later into a different game using &quot;Import GUI&quot;.
This allows you to design your interface and then use it in all your games.
<br>The &quot;New GUI&quot; button creates a new element. You can change which element you
are editing by clicking the up and down arrow buttons.
<br>In the top part of the screen the current GUI element is displayed. You can
change the size of the rectangle by dragging the lower-right hand corner of
it with the mouse.
<br>You will also notice a window titled &quot;Properties&quot;. This allows you to edit
the various properties of the GUI, and it works something like Visual Basic
(tm)'s Properties window. In the Properties window, you can change the
background colour of the GUI, set a background picture, and manually set the
location and width/height amongst other things.
<br>The &quot;Visible&quot; property allows you to set when the GUI is displayed. The
default is &quot;Always&quot;, which is like the Sierra status-line: always present
on the screen. The &quot;Script only&quot; option means that the GUI will be initially
off and must be turned on by a text script command. (NOTE: With this option,
the game will be paused when the GUI is displayed. If you don't want this
behaviour, set it to &quot;Always&quot; and use InterfaceOff in game_start). The
&quot;Mouse YPos&quot; option means that the GUI only appears when the mouse vertical
position moves above the y-coordinate set with the &quot;Popup-YP&quot; option.
The &quot;Clickable&quot; check box at the bottom of the screen allows you to set
whether the GUI and buttons on it respond to mouse clicks. This is on by
default, but if you turn it off and the player clicks on the GUI, the game
will actually process the click as if they clicked behind the GUI onto the
actual screen. Useful for transparent GUIs used to display information.
<p>
<font color=#00A000><u><b>4.2.1 GUI BUTTONS</b></u></font><br>
<br>To provide interactivity with the interface, you use buttons. There is no
limit to the number of buttons per GUI, but the game can only contain a total
of 80 GUI buttons.
<br>To add a button, click the &quot;Add button&quot; button, and then drag a rectangle
with the mouse onto the GUI. You will see it displayed as a text button, with
the text &quot;New button&quot; on. Notice that the Properties window is now displaying
properties for your new button rather than the GUI.
<br>Using the Properties window, you can set a picture for the button instead,
and you can also set various other self-explanitory attributes.
<br>You set what happens when the player clicks on the button by using the &quot;Left
clk&quot; attribute. This can be set to &quot;Do nothing&quot; (the default), and also &quot;Set
mode&quot;, which changes the cursor mode to the mode specified in the &quot;Clk data&quot;
property. The other option, &quot;Run script&quot;, runs the &quot;interface_click&quot; text
script function, passing the GUI number and button number of the clicked
button.
<br>To delete a GUI button, select it then press the Delete key on the keyboard.
<p>
<font color=#00A000><u><b>4.2.2 INTERFACE TEXT</b></u></font><br>
<br>You can also display text on interfaces. For example, the Sierra-style
interface displays the score in the status bar.
<br>To add text to a GUI, you add a label. Click the &quot;Add label&quot; button, then
drag out a rectangle like you did when adding a button. You can change the
text displayed in the label by editing the &quot;Text&quot; property. Notice that the
text automatically wraps round to fit inside the rectangle you drew.
<br>As well as typing normal text into the label, you can add some special markers
which allow the text to change during the game. The following tokens will be
replaced with the relevant values in the game:
<br> @GAMENAME@    The game's name, specified on the Game, Misc tab
<br> @OVERHOTSPOT@ Name of the hotspot which the cursor is over
<br> @SCORE@       The player's current score
<br> @SCORETEXT@   The text &quot;Score: X of XX&quot; with the relevant numbers filled
<br>                in. This string will be in the user's chosen language.
<br> @TOTALSCORE@  The maximum possible score, specified on Game, Misc tab
Example: You have @SCORE@ out of @TOTALSCORE@ points.
<br>The Properties window also allows you to align the text to left, right or
centre, as well as change its font and colour.
<p>
<font color=#00A000><u><b>4.2.3 TEXT WINDOWS</b></u></font><br>
<br>If you want to add a personal touch to the standard white text-boxes which
display all the messages during the game, you can create a border using the
GUI Editor. Create a new GUI element, and check the &quot;text window&quot; box for it.
The element will be resized to about 1/4 of the screen, and you will see 8
pictures - one in each corner and one on each side. These are the border
graphics. You change the graphic for a corner in the normal way.
<br>In the game, the corner graphics will be placed in the respective corners of
the text window, and the side graphics will be repeated along the edge of
the window. To tell the game to use your custom text window style, go to the
Game tab, &quot;Misc&quot; mode, and check the &quot;Text windows use GUI&quot; box in the top
part of the screen. When prompted, enter the number of the interface element
which you used.
<br>You can also set a background picture for the text window. In the GUI editor,
simply set a background picture for the GUI element. The graphic you specify
will not be tiled or stretched in the game; however, it will be clipped to
fit the window. You should use a graphic of at least about 250x80 pixels to
make sure that it fills up the whole window.
<p>
<font color=#00A000><u><b>4.2.4 LUCASARTS-STYLE INVENTORY</b></u></font><br>
<br>The final option you may have noticed in the GUI editor is the &quot;Add Inventry&quot;
button. This allows you to drag out a rectangle which will display the
player's current inventory, in the same way as the Lucasarts games did. To
make the inventory window scrollable, you will need to add Up and Down arrow
buttons, and attach text script code to those buttons to use the avaialble
variables such as game.top_inv_item, described in section 6.4.
<p>
<font color=#00A000><u><b>4.2.5 SLIDERS</b></u></font><br>
<br>You can now add sliders to your GUIs. This allows you to have a nice interface
for the player to change settings such as volume and game speed.
<br>To add a slider, click the &quot;Add slider&quot; button and drag out its rectangle just
like you would for a button. You can also resize it by dragging the bottom-
right hand corner out in the same way as a button.
<br>Sliders can be either vertical or horizontal. The direction that it is drawn
in is automatic depending on the size that you stretch the slider box to - if
it is wider than it is tall you will get a horizontal slider, otherwise you'll
get a vertical slider.
<br>For the properties of a slider you can set the minimum, maximum and current
values that the slider can have. In the game, the user will be able to drag
the handle from MIN to MAX, and the slider will start off set to VALUE.
For horizontal sliders, MIN is on the left and MAX on the right, for vertical
sliders MAX is at the top and MIN is at the bottom. Whenever the user moves
the handle's position on the slider, interface_click is called with the GUI
and object numbers of the slider. This means that if they continually drag
the handle up and down, interface_click will get called repeatedly.
<br>Your script can find out the value of the slider using the GetSliderValue
text script command.
<p>
<font color=#00A000><u><b>4.2.6 TEXT BOXES</b></u></font><br>
<br>You can now add Text Box controls to your GUI. A text box is a simple device
that allows the player to type information into your game. Adding a text box
works like adding the other types of control.
<br>If a text box is on a currently displayed GUI, all standard keypresses (ie.
letter keys, return and backspace) are diverted to the textbox instead of
being passed to the on_key_press function. When the player presses Return in
the text box, the interface_click function is called with the text box's GUI
and object number. You can then use the GetTextBoxText text script function
to retrieve what they typed in.
<p>
<font color=#00A000><u><b>4.2.7 LIST BOXES</b></u></font><br>
<br>List box controls allow you to add a list of items to your GUI. This could
be useful for doing a custom save/load dialog box, allowing the user to
choose between various options, and so forth.
<br>You use the ListBox text script functions to manipulate the list box - for
example, ListBoxAdd to add an item, or ListBoxGetSelected to get the current
selection.
<br>interface_click is fired with the listbox GUI/OBJECT ID's when the player
clicks on an item in the list. You may wish to ignore this or to do something
useful with it.
<p>
<font color=#00A000><u><b>4.2.8 UPGRADING INTERFACES TO GUIs</b></u></font><br>
<br>When you load a v2.06 or earlier game into RoomEdit, it will display a message
telling you that the interfaces have been upgraded. Most of the process is
automatic - however, you should check the new GUIs to make sure they converted
properly. Also, any interface text which you were using is not converted - you
will need to re-create it using labels.
<br>A couple of major things to note with the new GUIs:
<br>First, you can no longer access interface properties, like vtext, from the
text script using the &quot;iface&quot; variable. Code using this will still compile
and run, but will not have any affect on the game.
<br>You can now change the text instead by using the SetLabelText function -
described in the text script reference, section 6.3.
<br>Also, the &quot;$c&quot;, &quot;$r&quot; and &quot;$l&quot; alignment tags for the status bar text are
no longer supported - they have been replaced by the &quot;Align&quot; attribute of
labels.
<br>Finally, it is currently not possible to delete buttons or GUIs.
<p>
<font color=#00A000><u><b>4.3 DISTRIBUTING YOUR GAME</b></u></font><br>
<br>When you choose the &quot;Save game...&quot; button in the Room Editor, as well as
creating data files which it needs for itsself, the program will create an
executable file with the name of your game, in the directory above where all
the other files are stored.  This single file contains all of the program
code and data for your game, and is the file you should distribute. You may
remember that AC v1.14 included the ability to make a data file so that you
only needed to distribute it and the exe file - well this goes one step
further! Copy the USERGAME.EXE file to another directory or drive, or even
another computer, and there you have your game, contained in a single file!
Note, though, that you should also include the SETUP.BAT file to allow the
user to run the Setup program.
<br>NOTE: It is not possible to load the exe file back into the Room Editor. This
means two things when only the EXE file is available: (1) other people can't
edit your game's data, and (2) you can't either. Always keep a backup of the
other files produced (*.CRM, AC2GAME.DTA, etc) as they are what the Editor
needs to be able to load your game for editing.
<br>NOTE: Read the LICENSE.TXT file included for information on what you may, and
may not, distribute with your game.
<br>NOTE: MP3 music files are not included in the exe. They will instead be
built into a file called MUSIC.VOX when you click the &quot;REBUILD VOX FILES&quot;
button in RoomEdit. Since MP3s override all other music file types, this
allows you to have an MP3 Music Pack which you can distribute seperately to
your game. If it is present in the game directory it will be used, otherwise
any other music avialable (eg. MIDI) will be played instead.
<br><font color=#00A000><u><b>4.3.1 CUSTOM ICON</b></u></font><br>
<br>If you wish, you can use your own custom icon when you build a Windows EXE
file. To do this, simply place your icon in your game's folder, and name
it USER.ICO. Then, load Roomedit, make sure it says &quot;Target: Win&quot; and click
the &quot;Save Game&quot; button.
<br>Your icon must be standard 32x32 pixels in 16-colour. If it is any other size
or colour depth, RoomEdit will give an error.
<br><font color=#00A000><u><b>4.3.2 SPLITTING RESOURCE FILES</b></u></font><br>
<br>Some people found that once their game became large, the single EXE file
was slow at changing rooms. AGS now includes an option to split up the
resource files into smaller chunks to avoid this happening. On the Game,
Main tab you'll notice a checkbox &quot;Split resource files up into X Mb&quot;. If
you tick this, then type in a number such as 1 or 2, then save the game,
the game data will be split up into chunks that size, named GAME.001,
<br>GAME.002 and so on. Some resources are still combined into the EXE file but
all the rooms will be placed into the other files.
<br>If you use this option, you need to distribute your game's EXE file plus
all the GAME.00? files.
<p>
<font color=#00A000><u><b>4.4 TEXT SCRIPTING</b></u></font><br>
<br>Version 2 of AGS includes a radically overhauled text scripting system which
is now much more powerful and allows you much greater control of the game
through the scripts, if that is what you want to do.
<p>
***PLEASE NOTE: There is now a much better text script tutorial in the
seperate file, actutor.htm. Please refer there first for a good introduction.
<p>
The script language is based on the 'C' programming language, and anyone
familiar with C should be able to pick it up very quickly. If not, I will
introduce it now:
<br>Basically, the script consists of FUNCTIONS. Each function (think of it as
an event handler) is run when a particular event occurs. For example, the
&quot;on_key_press&quot; function is run whenever the user presses a key on the keyboard.
The code within the function is executed in procedural fashion - ie. from the
top downwards, one statement at a time. The function outlines look as follows:
function name_of_function() {
<br>  // your code here
<br>  }
<br>The keyword FUNCTION identifies this as the start of the function. Next is
the function's name. This can consist of any letters A-Z, plus underscores.
Note that spaces and numerical digits are NOT allowed in the name. After the
name are the brackets (). These define what parameters will be passed to the
function. In this case, there are none. Next comes the  {  symbol. This
signifies the start of the code block. Execution of the function starts after
this symbol and finishes at the  }  symbol, which signifies the end of the
function.
<br>To store information, you use variables. A VARIABLE is a block of memory which
holds a number or string of text. You define a variable as follows:
<br>int  my_counter ;
<br>The &quot;int&quot; is the type of variable you want to create. Available types are
&quot;char&quot;, which stores a 1-byte character, &quot;int&quot; which stores a 32-bit integer,
and also &quot;string&quot; which stores up to a 200-byte text string.
The &quot;my_counter&quot; is the name of the variable. You then use this name in the
script to refer to the variable.  The semicolon marks the end of the statement.
The scripting language requires every statement to end with a semicolon. If
you get a &quot;Parse error&quot; when your script is compiled, this is the first thing
to check.
<br>You declare variables at the top of the script, BEFORE any functions.
<br>To assign a value to a variable, use the  =  operator. For example,
<br> my_counter = 1;
<br>will set the &quot;my_counter&quot; variable to 1. Notice again the semicolon - they are
required after every statement. You can also add variables together, and do
simple maths with the assignments. For example,
<br> my_counter = other_counter - 5;
<br>will set &quot;my_counter&quot; to the value of &quot;other_counter&quot; minus 5.
I think it's time for an example script function. So:
<br>function on_key_press(int key_code) {
<br>  my_counter = my_counter + 1;
<br>  }
<br>The above script will increment the &quot;my_counter&quot; variable every time a key is
pressed.
<br>NOTE: If you are simply adding a value to a variable, shortcuts are available.
These are the  +=  and  -=  operators. For example,  &quot;my_counter += 1;&quot;  is
equivalent to   &quot;my_counter = my_counter + 1;&quot;.
<br>To compare variables, you use the IF keyword with the following operators:
==   is equal to
<br>&gt;    is greater than
<br>&lt;    is less than
<br>!=   is not equal to
<br>For example,
<br>  if ( my_counter &lt; 5 ) {
<br>    my_counter = my_counter + 1;
<br>    }
<br>will increment &quot;my_counter&quot; if it is less than 5. Note the use of the curly
brackets again - these define what code will be executed depending on the
result of the comparison.
<br>NOTE: You will notice that the &quot;is-equal-to&quot; operator == is different from
the assignment operator = . Do not get these mixed up, because using a single
equals in an &quot;if&quot; statement can cause major bugs in your script.
IMPORTANT NOTE: Do NOT use the = or == operators with string variables, or
you will get strange results. You must use the provided functions (whose
names begin with &quot;Str&quot;) to compare and assign strings. This is VERY IMPORTANT.
IMPORTANT NOTE: The script system is case-sensitive. That means, that the
variable names &quot;my_counter&quot;, &quot;My_Counter&quot; and &quot;MY_COUNTER&quot; are all different.
<p>
To call a function (listed in the section 6.3, below), you use the function
name, followed by its parameters in parenthesis, then a semicolon. For
example, to add inventory item 2 to the player's inventory, do this:
<br>AddInventory (2);
<br>The space between the function name and parenthesis is optional.
<br>If the function returns a value, you can capture it using the standard '='
operator. So, for example:
<br>int currentchar;
<br>currentchar = GetPlayerCharacter();
<br>will store the current player character number in the currentchar variable.
You can also use the function directly in a statement much as you would
use a variable, for example:
<br>if (IsGamePaused() == 1) {
<br>  // your code here
<br>  }
<br>would execute the code if the IsGamePaused function returned 1.
<p>
Section 6.3 further down lists all the text script commands that are avilable.
Each command is described with the parameters it takes, and the description
will mention if it returns a value. For example, this entry from section 6.3:
<br>GetSaveSlotDescription (int slot, string description)
<br>  Returns 1 if successful, 0 otherwise.
<br>This entry means that the function accepts two parameters, the first is an
integer (ie. a number), and the second is a string. Where a string is required
you can either pass a string variable or just type the string in directly
using speech marks. So you could call that function as follows:
<br>if (GetSaveSlotDescription (10, buffer) == 1) {
<br>  Display(&quot;Successful&quot;);
<br>  }
<br>else {
<br>  Display(&quot;Failed.&quot;);
<br>  }
<p>
NOTE: If you are an experienced programmer, please NOTE THE FOLLOWING: The
compiler will allow you to use 'C'-type pointers in your code, for example
using int*, char* and so on. However, DO NOT DO THIS as the data will be
corrupted when the user does a Save/Load game position.
<p>
Adventure Game Studio has two types of script files - &quot;global&quot; scripts and
&quot;local&quot; scripts. There is one global script in a game, and it is always
loaded in memory. This is the script which contains instructions for game-wide
events, like the key_press event.
<br>Each room file also has its own local script. Both types of script use the
same syntax and have the same functions available to them. The local script
for a room is only in memory while that room is loaded, in order to save
memory. So although you could put all your code into the global script, using
the local scripts for functions which you only need in that particular room
will save memory and help speed up the game.
<br>To edit a room's local script, load the room into the Room Editor, and then
choose the &quot;Edit scripts&quot; button from the ROOM, Setup Screen tab.
To edit the game's global script, click the &quot;Edit script&quot; button on the GAME,
Misc tab.
<p>
If you want to share information between room scripts and the global script,
there are 300 global variable slots which you can store numbers in.
<br>Use the function  SetGlobalInt (index, value);   to set variable INDEX to
VALUE, and then  GetGlobalInt (index);  to get the value back again.
<br>You can access the graphical script's global flags by using the gs_globals[]
array, but the numbers are shifted down one. So,  gs_globals[3]  is GLOBAL4
from the graphical script. A value of 1 means flag set and 0 means clear.
<p>
Currently it is not possible to call functions in other scripts - that is,
you can't write a function in the global script, and call it from a room
script. I hope to add support for this in a later version.
<p>
All co-ordinates used with functions in the script system are from 0 to 319
for X and from 0 to 199 for Y, where (0,0) is the top-left corner of the
screen, and (319, 199) is the bottom-right corner. This is independant of the
screen resolution the user is using - all co-ordinates are converted to the
320x200 scheme for scripting.
<br>NOTE: In a scrolling room, the maximum co-ordinates are larger than this. To
find out, go to the Rooms, Setup Screen tab, and load in your scrolling room.
Under the &quot;Options&quot; button is a line which says: &quot;Size: 320 x 200&quot; (or
whatever the size of your room is). The co-ordinates you can use range from
0 to the width/height minus 1. Remember that you can use the &quot;Ask Position&quot;
button to find out the co-ordinates of a point on the room.
<p>
A complete list of all the functions and variables available in the text
script system is in section 6.3, below.
<p>
<font color=#00A000><u><b>4.4.1 TEXT SCRIPT EVENTS</b></u></font><br>
<br>In your main global script file, there are some functions which are
automatically added when you create the game. These are &quot;events&quot;, and the
function is called when a particular event happens. There are also some
other events which you can add if you want to.
<br>The available event functions are:
<br>dialog_request (int parameter)
<br>  Called when a dialog script line &quot;run-script&quot; is processed. PARAMETER is
<br>  the value of the number following the &quot;run-script&quot; on that line of the
<br>  dialog script.
<br>game_start ()
<br>  Called at the start of the game, before the first room is loaded. You can
<br>  use this to set up the initial positions of characters, and to turn
<br>  interfaces on and off.
<br>gscript_request (int parameter)
<br>  Called when the graphical script &quot;Run text script&quot; command is used.
<br>  The value of PARAMETER is the &quot;%d&quot; replacement in the graphical script.
interface_click (int interface, int button)
<br>  Called when the player clicks on a button on an interface which has its
<br>  action set as &quot;Run script&quot;. INTERFACE is the number of the GUI which they
<br>  clicked on. BUTTON is the object number of the button within this GUI.
on_event (int event, int data)
<br>  Called whenever certain game events happen. The value of DATA depends on
<br>  which event has occured. This allows you to perform checks or update things
<br>  every time the player does something, regardless of which room it is in.
<br>  The possible values of event are:
<br>  ENTER_ROOM    called just before room Player Enters Screen event is run.
<br>                DATA = new room number
<br>  LEAVE_ROOM    called just after room Player Leaves Screen event is run.
<br>                DATA = room number they are leaving
<br>  EGO_DIES      called when the &quot;Player Dies&quot; interaction occurs.
<br>                DATA = the Data column value of the Player Dies interaction.
<br>  GOT_SCORE     called whenever the player's score changes
<br>                DATA = number of points they got
<br>  GUI_MDOWN     mouse button pressed over a gui
<br>                DATA = GUI number
<br>  GUI_MUP       mouse button released
<br>                DATA = GUI number it was pressed down over
<br>  ADD_INVENTORY the player just got a new inventory item
<br>                DATA = inventory item number that was added
<br>  LOSE_INVENTORY the player just lost an inventory item
<br>                DATA = inventory item number that was lost
<br>on_key_press (int keycode)
<br>  Called whenever a key is pressed on the keyboard. KEYCODE holds the ASCII
<br>  value of the key. A list of these values is in section 6.6, below.
<br>on_mouse_click (int button)
<br>  Called when the player clicks a mouse button. BUTTON is either LEFT or
<br>  RIGHT, depending on which button was clicked. The &quot;mouse.x&quot; and &quot;mouse.y&quot;
<br>  global variables contain the mouse's position.
<br>repeatedly_execute ()
<br>  Called every game cycle (normally 40 times per second).
<br>unhandled_event (int what, int type)
<br>  Called when an interaction is run, but no events are listed in the
<br>  interaction window. This could be used to display a default &quot;I can't do
<br>  that&quot; type of message. The values of WHAT and TYPE tell you what the
<br>  player did. The possible values are listed below:
<br>  WHAT TYPE Description
<br>   1    1   Look at hotspot
<br>   1    2   Interact with hotspot
<br>   1    3   Use inventory on hotspot
<br>   1    4   Talk to hotspot
<br>   1    7   Pick up hotspot
<br>   2    0   Look at object
<br>   2    1   Interact with object
<br>   2    2   Talk to object
<br>   2    3   Use inventory on object
<br>   2    5   Pick up object
<br>   3    0   Look at character
<br>   3    1   Interact with character
<br>   3    2   Speak to character
<br>   3    3   Use inventory on character
<br>   4    1   Look at nothing (ie. no hotspot)
<br>   4    2   Interact with nothing
<br>   4    3   Use inventory with nothing
<br>   4    4   Talk to nothing
<br>   5    0   Look at inventory
<br>   5    1   Interact with inventory (currently not possible)
<br>   5    2   Speak to inventory
<br>   5    3   Use an inventory item on another
<br>   5    4   Other click on inventory
<br>  Note that the &quot;Character stands on hotspot&quot;, and all &quot;Any click&quot; events
<br>  do not trigger this function.
<p>
<font color=#00A000><u><b>4.4.2 CALLING GLOBAL FUNCTIONS FROM LOCAL SCRIPTS</b></u></font><br>
You can now call your global script functions directly from your rooms. This
means that if you have a common script that you want to use in response to
various different events during the game, you can call it from your rooms
rather than duplicating code.
<br>To use a global function, open up the main script header (the &quot;Edit header&quot;
button on the Game, Main tab), and add a line similar to the following:
import function my_function_name (parameters);
<br>Where my_function_name is the name of the global script function, and
<br>parameters is a list of the TYPES ONLY of the parameters it takes. For example,
if you had in your global script:
<br>function do_animation (int anim_number) {
<br>then you would write:
<br>import function do_animation (int);
<br>To use the function, you just call it normally in your script, eg:
<br>do_animation (3);
<br>You can also return a value to the caller by using the &quot;return&quot; statement,
and the local script picks this up the same way it does with built-in
<br>functions. For example, the end of your global script function could be:
return 51;
<br>then the local script just does:
<br>int value = do_animation(3);
<p>
<font color=#00A000><u><b>4.4.3 THE SCRIPT HEADER FILE</b></u></font><br>
<br>This allows you to include the same information into all your scripts. For
example, if you have a global function you want all the room scripts to use,
you can add its import definition to the header file.
<br>Do NOT place any actual functions or variables in this header, because if
you do you will need to re-compile ALL the scripts whenever you modify the
function. Instead, place your functions in your global script and just place
an import line in the header file to allow the other scripts to access it.
<p>
<font color=#00A000><u><b>4.4.4 OTHER SCRIPT NOTES</b></u></font><br>
<br>Only one text script can be executing at any one time. A script is considered
to be &quot;executing&quot; if there is still code left in a script function that needs
to be executed.
<br>What this means is that if you call a function like MoveCharacterToObject,
which is BLOCKING - that is, it waits until the character finishes moving
before continuing the script - then while the character is moving no other
scripts will be run (for example, repeatedly_execute scripts).
<p>
<font color=#00A000><u><b>4.5 DUMPING TEXT TO FILE</b></u></font><br>
<br>AGS now has the ability to dump all of your in-game text out to a flat text
file, which you can edit by hand and then import back later.
<br>This is very useful for things such as translations, where the file can
just be translated rather than having to go into each room, edit the messages
there, and so on.
<br>The text dumper is located on the Advanced tab, then the &quot;Dump text&quot; mode.
Here you have five check-boxes where you can choose which parts of the game
you want exported. By default they are all selected; however, if you wish
you can de-select things you don't need to export. Once done, click the Dump
Text To File button, type a file name, and click OK. When you exit Roomedit,
you should find that file inside your game's folder ready to be edited.
NOTE: The file contains special tags, which look like this:
<br>$$$!$$$ GM 3
<br>DO NOT MODIFY THESE LINES IN ANY WAY. They are used by roomedit to track what
each line of the file means, and changing any of the special lines could
really mess up your game when you import it back.
<br>When you have made your changes to the text file, and want to combine it back
into the game, first of all MAKE A BACKUP COPY OF YOUR GAME FOLDER. Because
the import operation jibbles every part of your game, if it crashes or messes
up at any point, your game is most likely lost. So, make a backup of your
game before proceeding.
<br>Once done, go back to the &quot;Dump text&quot; mode, select the things you want to
import back in, then click the &quot;Read from file&quot; button. There you can select
the text file to import, and it should import everything back in.
<br>In conclusion, the Dump Text feature is a very powerful tool, however you MUST
be careful with its use or you could corrupt your game beyond repair.
<p>
<font color=#00A000><u><b>4.6 THE TEXT PARSER</b></u></font><br>
<br>You can now use a text parser in your games if you wish to, much as the older
Sierra games did. The way it works is as follows:
<br>On the Advanced tab of Roomedit, go to the &quot;Text parser&quot; mode. There, you
will see a short list of words which are provided for you. Each word has a
number beside it.
<br>Basically, you add words you want to use by clicking the &quot;Add word&quot; button.
However, the real beauty of the parser is its ability to recognise synonyms -
that is, two words that mean the same thing. So, for example, if you wanted
the player to type &quot;look at fence&quot;, they might well type &quot;look at wall&quot;
instead, if that's how they see the drawing. Or, a British person might type
&quot;colour&quot; whereas an American might type &quot;color&quot;, both of which should have
the same effect.
<br>To add a synonym for an existing word, highlight the current word, and click
the &quot;Add synonym&quot; button. You'll notice that the new word is given the same
number as the old one. All words with the same number are considered identical
by the parser.
<br>You will notice that the provided list has a lot of words with number 0. This
is a special number, that indicates that the parser should ignore the word
completely. In our previous example, the player might type &quot;look at the fence&quot;,
&quot;look at fence&quot;, or just &quot;look fence&quot;. By adding words like &quot;at&quot; and &quot;the&quot; to
the ignore list, they get stripped out of the user's input automatically. To
add new ignore words, just select an existing one and add a synonym.
<br>So, how do you use the text parser? Well, you'll need a text box GUI control
somewhere in order for the user to type in their input, or you could just
use the InputBox command (but it has quite a short line length).
<br>When the user has typed in their text (you'll probably know this by the text
box's interface_click being activated), you call the  ParseText  script
function which tells AGS what input string to use in subsequent commands.
You then simply use the Said command to test what the player typed in. You
type the whole sentence (but NOT including any ignore words), and AGS will
compare it to the user's string, considering all synonyms identical.
<br>For example (assuming our text box is object 6 on GUI 3):
<br>  string input;
<br>  GetTextBoxText (3, 6, input);
<br>  ParseText (input);
<br>  if (Said(&quot;look fence&quot;)) {
<br>    Display(&quot;It's an old wooden fence.&quot;);
<br>  }
<br>  if (Said(&quot;eat apple&quot;)) {
<br>    Display(&quot;You'd love to, but you don't have one.&quot;);
<br>  }
<p>
There are a couple of special words you can use with the Said command.
&quot;anyword&quot; will match any word that the user types in. For example,
Said(&quot;throw anyword away&quot;)  will match if they type &quot;throw dagger away&quot;,
or &quot;throw trash away&quot;.
<br>&quot;rol&quot; (short for Rest-of-Line) will match the rest of the user's input. So,
you might want to do:
<br>if (Said(&quot;kill rol&quot;)) {
<br>  Display(&quot;You're not a violent person.&quot;);
<br>}
<br>This way if they try to kill anything they will get the generic response.
<p>
Sometimes, you want to accept two different words that are not synonyms as
the same thing. For example, the words &quot;take&quot; and &quot;eat&quot; normally have totally
different meanings, so you wouldn't make them synonyms of each other. However,
if the player has a headache tablet, for instance, then &quot;take tablet&quot; and
&quot;eat tablet&quot; would both be valid. This is where the comma &quot;,&quot; comes in - if
you include a comma in your input, all synonyms of all words seperated by
the comma will match. So:
<br>if (Said(&quot;eat,take tablet&quot;))
<br>will match eat or take and all their synonyms, then tablet and its synonyms.
<p>
<font color=#0000A0 size="+1"><u><b>5. Upgrading from AC v1</b></u></font><br>
<br>If you have used AC version 1.xx, and you want to continue with a game you
were making using this new version, this section describes the major changes
and what to do about them.
<br>Of course, first of all you will need to get to know the new Room Editor. I'd
recommend reading through the tutorial in this file, as it will introduce you.
Instead of the old Condition List, the conditions are now split up into the
individual events. Where there are conditions now, an &quot;Interaction&quot; button is
available on those tabs. Clicking this gives a window where you can set the
responses you want to implement for those events.
<p>
<font color=#00A000><u><b>5.1 CHANGES FROM v1</b></u></font><br>
<br>MAJOR CHANGES<ul>
<li>The walls system has been completely changed. Now, instead of defining the
walls on the screen, you instead define where the character CAN walk, by
using walkable areas. This is to stop the problem where the player could
wriggle through the walls. The shadow screen (Special menu of old RoomMake)
has been incorporated into the walls screen - you can colour-code the
<br>walkable areas, and each colour can be assigned a view number.</li>
<li>When importing old rooms, all misc conditions are lost. You must check each
room, and if it uses misc conditions, replace them with either a graphical
script or text script. The Room Editor will warn you if you load an old room
file which uses misc conditions.</li>
<li>There is no longer just one text script file which you edit and then compile.
Now, text scripts are built into the room files (local text scripts) and
into the main game file (global text scripts).</li>
</ul>
<br>OTHER CHANGES<ul>
<li>The X,Y co-ordinate positions of the characters are now the bottom-middle
of the character (in AC 1 it was the bottom-left). This makes the pathfinding
much better than before because the man won't walk over the walls on the
right. Note that the objects are still bottom-left.</li>
<li>In the text script, the player's inventory now has a different variable name:
it is now  &quot;character[EGO].inv[X]&quot;  rather than just  &quot;inv[X]&quot;. This is
because v2 supports different characters each carrying their own inventory.</li>
<li>The &quot;runcondition&quot; text script command has been removed. It was confusing
and everything which it could do is now done seperately by different
<br>commands.</li>
<li>In fact, the whole text script system has been changed, once again.
Sorry. I promise to keep it this way from now on :-)  But you'll be glad
to know that the language is still the same, just the commands are different.
I'd recommend reading sections 4.4 (intro to text scripting) and more
<br>importantly 6.3 (text script command reference) to introduce yourself.</li>
</ul>
<br><font color=#00A000><u><b>5.2 STEP-BY-STEP: CONVERTING v1 GAMES</b></u></font><br>
<p>
From v2.2 onwards, AGS can no longer import v1.xx games.
<br>(It's been 2 years now since v2.00 was released, so I find it unlikely that
anyone still has any).
<p>
If you need to import a v1 game, download an older version of AGS such
as v2.07, use that to import your v1.xx game, then import that game into
the current version.
<p>
<font color=#0000A0 size="+1"><u><b>6. Command reference</b></u></font><br>
<br>This section contains a complete reference for the room &quot;interaction&quot; events
and commands, and a comprehensive description of all the text script functions
available.
<p>
<font color=#00A000><u><b>6.1 INTERACTION EVENTS</b></u></font><br>
<br>The following events are available in Interaction windows:
<br><font color=#00A000><u><b>6.1.1 HOTSPOT INTERACTIONS<ul></b></u></font><br>
<li>Character stands on hotspot - occurs repeatedly while the player character
is standing on the hotspot.</li>
<li>Look at hotspot - occurs when the player clicks on the hotspot while in
the &quot;Look&quot; mode (cursor mode 1).</li>
<li>Interact with hotspot - occurs when the player clicks on the hotspot while
in the &quot;Interact&quot; mode (cursor mode 2).</li>
<li>Use inventory on hotspot - occurs when the player clicks on the hotspot
while in the &quot;Use inventory&quot; mode (cursor mode 4), but ONLY if the player
is using the inventory item number which the Data column is set to. For
example, if you want to respond when the player is using a key (inventory
item 2), then set Data to 2. You can also set Data to 99, in which case the
event will trigger for any inventory item - in this case, you can use the
&quot;If inventory %d was used&quot; graphical script command (see section 6.7), or the
text script variable character[x].activeinv (see section 6.4) to find out
what was used.
<br>IMPORTANT: When this event is triggered, and if Data is not 99, then the
player will lose the inventory item.
<br>NOTE: Because the Data column is used for the event, you cannot use a
<br>response which also requires a Data value. You must use a text script or
graphical script to respond in this case.</li>
<li>Speak to hotspot - occurs when the player clicks on the hotspot while in
the &quot;Talk&quot; mode (cursor mode 3).</li>
<li>Any click on hotspot - occurs when the player clicks on the hotspot in
any cursor mode (except Walk). This allows you to add extra modes like
smell, taste, push, pull, and so on. This event also occurs as well as
the other event for the Look, Interact and Talk modes.</li>
<li>Mouse moves over hotspot - occurs repeatedly while the mouse cursor is
over the hotspot. You can use this to highlight the cursor, and for other
various effects.</li>
</ul>
<br><font color=#00A000><u><b>6.1.2 OBJECT INTERACTIONS<ul></b></u></font><br>
<li>Look at object - occurs when the player clicks on the object while in
the &quot;Look&quot; mode (cursor mode 1).</li>
<li>Interact with object - occurs when the player clicks on the object in
the &quot;Interact&quot; mode (cursor mode 2).</li>
<li>Speak to object - occurs when the player clicks on the object in the
&quot;Talk&quot; mode (cursor mode 3).</li>
<li>Use inventory on object - works like &quot;Use inventory on hotspot&quot; - see
that desccription (section 6.1.1 above) for more information.</li>
</ul>
<br><font color=#00A000><u><b>6.1.3 ROOM INTERACTIONS<ul></b></u></font><br>
<li>Walk off left - occurs when the player character walks off the left edge
of the screen.</li>
<li>Walk off right - occurs when the player walks off the right edge of the
screen.</li>
<li>Walk off bottom - occurs when the player character walks off the bottom
edge of the screen.</li>
<li>Walk off top - occurs when the player character walks off the top edge
of the screen.</li>
<li>First time enters screen - occurs the first time the player enters the
room. This event occurs AFTER the screen has faded in, so it allows you to
display a message describing the scene.</li>
<li>Player enters screen - occurs just after the room is loaded into memory.
This event occurs every time the player enters the screen, and it happens
BEFORE the screen has faded in, which allows you to change object graphics
and do other things to the screen which the player won't notice.
<br>NOTE: This event is ONLY meant for adjusting things such as object and
character placement. Do NOT use this event for any sort of automated intro
to the room - use the &quot;Enters Screen After Fade In&quot; event for that instead.</li>
<li>Repeatedly execute - occurs repeatedly on every interpreter cycle. The
normal game speed is 40 cycles per second, so this event occurs about
<br>every 25 milliseconds.</li>
<li>Enters screen after fadein - occurs every time the player enters the
room, AFTER the screen has faded-in. Suitable for displaying text
descriptions and so on, that you want the player to see.</li>
<li>Player leaves screen - occurs when the player leaves the screen, just
before the screen fades out.</li>
</ul>
<br><font color=#00A000><u><b>6.1.4 INVENTORY ITEM INTERACTIONS<ul></b></u></font><br>
<li>Look at inventory - occurs when the player clicks on the inventory item
while in the &quot;look&quot; mode.</li>
<li>Interact with inventory - (not yet implemented).</li>
<li>Speak to inventory - only applies to the Lucasarts-style inventory,
occurs when the player clicks the Talk icon on the inventory item.</li>
<li>Use inventory on inv - occurs when the player uses another inventory
object on this one. You set the Data column to the number of the other item
which needs to be used on this item (see section 6.1.1 above for details
on the way this works). This event allows the player to combine items, and
so on. For example, if they had picked up a laptop computer and a battery,
seperately, then you could use this to allow them to insert the battery into
the computer.</li>
<li>Other click on inventory - only applies to the Lucasarts-style inventory,
occurs when the player clicks any other cursor mode (apart from look, talk
and use_inv) on the item.</li>
</ul>
<br><font color=#00A000><u><b>6.2 INTERACTION COMMANDS</b></u></font><br>
<br>The following commands are available in response to events in Interaction
windows:<ul>
<li>Go to screen %d - changes the player character's current room to the %d.
If this is in response to one of the screen edge events, the character will
be placed on the opposite side of the screen. Otherwise, you must use the Data
column to specify where on the new screen the man is placed. You specify which
edge by using these numbers: 1000=left, 2000=right, 3000=bottom, 4000=top.
He will be placed in the middle of that side, unless you add the pixel offset
along the edge, which you can get from the &quot;Ask Position&quot; function in the
Setup Screen mode. For example, Data=2150 would place him near the bottom of
the right-hand side.</li>
<li>(Do nothing) - nothing happens.</li>
<li>Stop man walking - the player character stops moving if he is currently
moving.</li>
<li>Player dies - this command does not actually do anything other than
call the on_event text script event.</li>
<li>Run animation %d - runs an animation. Each room has animations numbered
from 1 to 9, so you can have up to 9 animations per room. Click the &quot;...&quot;
button to edit the animation.</li>
<li>Display message %d - displays a message. If the number is below 40, then
the room message of that number will be displayed. If the number is above
500, then the relevant global message is displayed.</li>
<li>Remove object %d - turns the specified object off. It will no longer
appear on this screen, until it is turned back on by the &quot;Turn object on&quot;
command.</li>
<li>Remv obj %d, add inv - turns the specified object off, and adds the
inventory number in the Data column to the player's inventory.</li>
<li>Add inventory %d - Adds the specified inventory item to the player's
inventory.</li>
<li>Run script - Runs a text script. Click the &quot;...&quot; button to edit the
script. Section 4.4, above, introduces the text script system.</li>
<li>Run graphical script - Runs a graphical script. Click the &quot;...&quot; button
to create the script. Section 3.3.3 describes the graphical script.</li>
<li>Play sound %d - plays the sound effect SOUNDx.WAV or SOUNDx.VOC, where X
is the number you supply. If the number is &gt;=1000, then this command will
instead change the background music to MUSICx.MID/MOD/XM, where X is the
number you supply minus 1000.</li>
<li>Play FLI/FLC %d - plays either FLIC%d.FLC or FLIC%d.FLI. If you set the
Data column to 1 then the player can skip the animation by pressing ESC.
Otherwise, they must watch the whole thing. For information on converting
AVI files to FLC, see section 7.1 .</li>
<li>Turn object %d on - turns the specified object on. Either it was
<br>previously turned off using the &quot;Remove object&quot; command, or it was set
to initially Off in the Room Editor.</li>
<li>Run dialog topic %d - starts a conversation, using topic number &quot;%d&quot; from
the Dialog Editor.</li>
</ul>
<br><font color=#00A000><u><b>6.3 TEXT SCRIPT FUNCTIONS</b></u></font><br>
<br>PLEASE NOTE: Most of the script functions are non-blocking: that is, they
return control immediately to the script, and then the function will be
performed while the game continues. However, a few of the functions, such
as &quot;Display&quot;, are blocking. In this case, the script does not continue until
the function has finished (in this example, the user has removed the message
box). Blocking functions are documented as such below.
<br>The following functions are available in the text script system. In
<br>alphabetical order:
<br>AddInventory (int what)
<br>  Adds inventory index WHAT to the current player character's inventory. This
<br>  has the same effect as doing  character[EGO].inv[WHAT]+=1;  however, it
<br>  will add the inventory to the current player character and also update
<br>  the inventory window.
<br>  SeeAlso: LoseInventory
<br>AnimateCharacter (CHARID, int loop, int speed, int repeat)
<br>  Starts character CHARID animating. See the description for AnimateObject for
<br>  more details, as this command is identical to AnimateObject except it works
<br>  with characters. If the character is moving it will be stopped.
<br>  SeeAlso: AnimateObject, SetCharacterView
<br>AnimateObject (int object, int loop, int speed, int repeat)
<br>  Starts the object number OBJECT animating, using loop number LOOP of its
<br>  current view. The overall speed of the animation is set with SPEED,
<br>  where 0 is the fastest, and increasing numbers mean slower. The delay for
<br>  each frame is worked out as SPEED + FRAME SPD, so the individual frame
<br>  speeds are relative to this overall speed.
<br>  The REPEAT parameter sets whether the animation will continuously repeat
<br>  the cycling through the frames. If REPEAT is zero, the animation will start
<br>  from the first frame of LOOP, and go through each frame in turn until the
<br>  last frame, where it will stop. If REPEAT is 1, when the last frame is
<br>  reached, it will go back to the first frame and start over again with the
<br>  animation. If REPEAT is 2, it will do the animation once, but then return
<br>  the graphic to the first frame and stop (whereas repeat=0 will leave the
<br>  graphic on the last frame).
<br>  SeeAlso: AnimateCharacter, SetObjectView
<br>AreCharactersColliding (CHARID1, CHARID2)
<br>  Checks if character CHARID1 is touching CHARID2. This function just checks
<br>  the base line of both characters, so that if one is standing a fair
<br>  distance behind the other, it will not be marked as colliding.
<br>  Returns 1 if the characters feet are touching, 0 otherwise.
<br>  SeeAlso: AreCharObjColliding, AreObjectsColliding
<br>AreCharObjColliding (CHARID, int obj)
<br>  Checks if character CHARID and object OBJ are touching each other.
<br>  Returns 1 if they are, and 0 if they are not.
<br>  NOTE: This function checks the character's feet against the whole of the
<br>  object. This is used to see if the character is standing on an object, and
<br>  so on. The top two-thirds of the character do not trigger.
<br>  NOTE: This function only performs a rectangular check, even when pixel-
<br>  perfect click detection is on.
<br>  SeeAlso: AreCharactersColliding, AreObjectsColliding
<br>AreObjectsColliding (int obj1, int obj2)
<br>  Checks if object OBJ1 and OBJ2 are touching each other. Returns 1 if they
<br>  are, and 0 if they are not.
<br>  NOTE: This function only performs a rectangular check, even when pixel-
<br>  perfect click detection is turned on.
<br>CDAudio (int command, int param)
<br>  This function allows you to play and control an audio CD in your game.
<br>  Different tasks are performed, depending on the value of the COMMAND
<br>  parameter. If there is no CD-ROM drive on the system, the function does
<br>  nothing.
<br>  The PARAM parameter is used by some of the functions for various reasons; if
<br>  it is not needed for the particular function you are calling, pass zero
<br>  instead.
<br>  The tasks performed are as follows depending on the COMMAND parameter:
<br>     0  Query CD-ROM support - checks if there is a CD-ROM drive available on
<br>        the system. Returns 1 if there is, and 0 if there is not.
<br>     1  Get playing status - checks whether the CD drive is currently playing
<br>        an audio track. Returns 1 if it is, and 0 if it is not.
<br>     2  Play track - starts playback from track PARAM on the CD. If the track
<br>        does not exist, or if it is a data track, nothing happens.
<br>     3  Pause playback - pauses the currently playing audio track.
<br>     4  Resume playback - continues from where the track was paused.
<br>     5  Get number of tracks - returns the number of tracks on the CD
<br>        currently in the drive. If the drive is empty, returns 0.
<br>     6  Eject - ejects the drive tray if the drive has the ability. This is
<br>        a feature you'll play with to start off because it's neat, and then
<br>        realize that it has no real use in your game.
<br>        Your script does not continue until the drive is fully ejected.
<br>     7  Close tray - the reverse of Eject. This will pull the drive tray back
<br>        in again. Your script does not continue until the drive has been
<br>        fully closed.
<br>     8  Get number of CD-ROM drives - returns the number of CD drives in the
<br>        system, normally 1.
<br>     9  Select current CD-ROM drive - changes the current CD drive to PARAM,
<br>        where PARAM ranges from 1 to (number of CD drives). All the other
<br>        CD Audio functions operate on the current CD drive.
<br>  NOTE: These CD Audio functions are slow compared to all the other script
<br>  functions. This will not be noticeable if you call them from most scripts,
<br>  but using CDAudio in a repeatedly_execute script will noticeably slow down
<br>  the game.
<br>  NOTE: If the game is run under plain MS-DOS, the user's CD-ROM driver will
<br>  need to be loaded in memory for these functions to work. If it is not, the
<br>  game assumes that there is no CD-ROM drive on the system.
<br>  NOTE: The Windows version of the engine only supports a single CD-ROM drive,
<br>  so functions 8 and 9 currently do not work.
<br>ChangeCharacterView (CHARID, int newview)
<br>  Changes the normal view number of character CHARID to NEWVIEW. This is
<br>  useful if, for example, you want the character to change the clothes
<br>  they are wearing, and so permanently alter their view number.
<br>  SeeAlso: SetCharacterView
<br>ChangeCursorGraphic (int mode, int slot)
<br>  Changes mouse cursor mode MODE's cursor graphic to SLOT.
<br>  This permenantely changes the specified mode's cursor graphic. This function
<br>  may be useful if you need more than the maximum number of mouse cursors.
<br>  SeeAlso: ChangeCursorHotspot, SetCursorMode
<br>ChangeCursorHotspot (int mode, int x, int y)
<br>  Permanently changes mouse cursor MODE's hotspot on the cursor graphic
<br>  to (X,Y). This is the offset into the graphic where the click takes effect.
<br>  (0,0) is the upper left corner of the cursor graphic.
<br>  SeeAlso: ChangeCursorGraphic
<br>CreateGraphicOverlay (int x, int y, int slot, int transparent)
<br>  Creates a screen overlay containing a copy of the image from SLOT in
<br>  the Sprite Manager. The image is placed at (X,Y) on the screen (these are
<br>  screen co-ordinates, not room co-ordinates). If TRANSPARENT is 1 then the
<br>  overlay will be drawn in the same way as characters/objects, if it is 0
<br>  then the a black rectangle will be painted behind the sprite.
<br>  See the description of CreateTextOverlay for more on overlays.
<br>  SeeAlso: CreateTextOverlay, RemoveOverlay
<br>CreateTextOverlay (int x, int y, int width, int font, int color, string text)
<br>  Creates a screen overlay containing the text you pass at the position
<br>  specified. A screen overlay looks identical to the way speech text is
<br>  displayed in conversations, except that with this command the text stays
<br>  on the screen until either you remove it with RemoveOverlay, or the player
<br>  goes to a different room, in which case it is automatically removed.
<br>  The X and Y parameters specify the upper-left corner of where the text
<br>  will be written. WIDTH is the width, in pixels, of the text area. FONT is
<br>  the font number from roomedit to use (0 is the normal font, 1 is the speech
<br>  font). COLOR is the text color - use one of the colours from 1 to 15.
<br>  Finally, TEXT is obviously the text that gets displayed.
<br>  The function returns the Overlay ID, which you use later to reposition
<br>  and remove the overlay.
<br>  NOTE: screen overlays, in the same way as objects, slow down the game
<br>        while displayed.
<br>  NOTE: there is currently a maximum of 3 overlays displayed at any one time
<br>  SeeAlso: CreateGraphicOverlay, MoveOverlay, RemoveOverlay
<br>CyclePalette (int start, int end)
<br>  This is used for special effects, like the flowing colours on the Space
<br>  Quest 4 title screen, and the Sierra logo of the later Sierra games.
<br>  The palette indexes from START to END are cycled around one slot. Using
<br>  this call in a repeatedly_execute function gives the effect of animation.
<br>  NOTE: This function does not work in hi-colour mode.
<br>  SeeAlso: FadeIn, FadeOut, SetPalRGB
<br>Debug (int command, int data)
<br>  This function provides all the debug services in the system. It performs
<br>  various different tasks, depending on the value of the COMMAND parameter.
<br>  If debug mode is off, then this function does nothing. This allows you to
<br>  leave your script unaltered when you distribute your game, so you just have
<br>  to turn off debug mode in the Room Editor.
<br>  The DATA parameter depends on the command - pass 0 if it is not used.
<br>  All the valid values for the COMMAND parameter are listed below along with
<br>  what they do:
<br>    0   All inventory - gives the current player character one of every
<br>        inventory item. This is useful for testing so that you don't have to
<br>        go and pick up items every time you test part of the game where they
<br>        are required.
<br>    1   Display interpreter version - the engine will display its version
<br>        number and build date.
<br>    2   Walkable from here - fills in the parts of the screen where the player
<br>        can walk from their current location. This is useful if you think the
<br>        path-finder is not working properly. Yellow areas are where the man
<br>        can walk. Blue areas are defined as walkable in the Room Editor, but
<br>        he cannot get to them from his current position. The unaltered parts
<br>        of the screen are not walkable.
<br>    3   Teleport - displays a dialog box asking for what room you want to go
<br>        to, and then calls NewRoom to teleport you there. Useful for skipping
<br>        parts of the game or going to a specific point to test something.
<br>    4   Show FPS - toggles whether the current frames per second is displayed
<br>        on the screen. Pass DATA as 1 to turn this on, 0 to turn it off.
DisableCursorMode (int mode)
<br>  Disables the mouse cursor MODE. Any attempts to set the cursor to this mode
<br>  while it is disabled (like using SetMouseCursor) will fail. This function
<br>  also greys out and disables any interface buttons whose left-click command
<br>  is set as &quot;Set mode X&quot;, where X is equal to MODE.
<br>  If the current cursor mode is MODE, then the engine will change it to the
<br>  next enabled standard cursor.
<br>  SeeAlso: EnableCursorMode
<br>DisableHotspot (int hsnum)
<br>  Disables hotspot number HSNUM in the current room. All areas of the screen
<br>  that were previously HSNUM now act as type 0 (no hotspot). You can turn it
<br>  back on later with the EnableHotspot command.
<br>  This command permanently disables the hotspot - that is, it will not be
<br>  reset when the player re-enters the room. The only way of turning the
<br>  hotspot back on is to use the EnableHotspot command.
<br>  SeeAlso: EnableHotspot, RemoveWalkableArea
<br>DisableInterface ()
<br>  Disables the player interface. This works the same way as it is disabled
<br>  while an animation is running: the mouse cursor is changed to the Wait
<br>  cursor, and mouse clicks will not be sent through to the &quot;on_mouse_click&quot;
<br>  function. Also, all interface buttons will be disabled.
<br>  SeeAlso: EnableInterface, IsInterfaceEnabled
<br>Display (string message, ...)
<br>  Displays a message to the screen. It will be displayed in the standard
<br>  message box, and centred in the middle of the screen. You can insert the
<br>  values of variables using &quot;%d&quot; and &quot;%s&quot; in the message. To insert the value
<br>  of an integer variable, use %d, to insert a string use %s. For example,
<br>  Display (&quot;The counter is currently set to %d.&quot;, my_counter);
<br>  This will replace the '%d' with the value of the variable &quot;my_counter&quot;.
<br>  Note: Display is a blocking function - that is, control will not return
<br>  to the script until the player has removed the text window (by pressing a
<br>  key or clicking the mouse). While the window is displayed, all other
<br>  processing, like animations and interface display, are disabled. This is
<br>  usually used for responses to the player LOOKing at things.
<br>  SeeAlso: DisplayAt, DisplayMessage, DisplaySpeech, StrFormat
<br>DisplayAt(int x, int y, int width, string message, ...)
<br>  Identical to the &quot;Display&quot; function, only this allows you to define the
<br>  position and size of the window where the text is displayed. The X and Y
<br>  variables define the co-ordinates of the upper-left corner of the window.
<br>  The WIDTH variable defines the width of the window. The height is then
<br>  automatically calculated so that the message fits into the window.
<br>  Note: This is a blocking call. See the &quot;Display&quot; help for more information.
<br>  SeeAlso: Display, DisplayAtY
<br>DisplayAtY (int y, string message)
<br>  Similar to the Display function, except that this will display the message
<br>  box at the specified Y location on the screen. The Y defines the co-ordinate
<br>  of the top of the message box. The horizontal positioning will be
<br>  automatically calculated as usual.
<br>  SeeAlso: Display, DisplayAt
<br>DisplayMessage (int message_number)
<br>  Identical to the Display function, but this uses a message text defined in
<br>  the Room Editor rather than in the script. It will either use a message
<br>  from the current room, or a global message (if message_number &gt;= 500).
<br>  SeeAlso: Display
<br>DisplaySpeech (CHARID, string message)
<br>  Displays the text MESSAGE as speech above the specified character's head.
<br>  The text will remain on screen for a limited time, and the user may or may
<br>  not be able to click it away depending on the setting of &quot;Player can't
<br>  skip speech text&quot;. The text displayed by this function looks identical to
<br>  that used by the dialog system.
<br>  NOTE: This function does not allow variables like &quot;%d&quot; and &quot;%s&quot; in the
<br>  message.
<br>  SeeAlso: Display, DisplaySpeechBackground
<br>DisplaySpeechBackground (CHARID, string message)
<br>  Similar to DisplaySpeech, except that this function returns immediately
<br>  and the game continues while the character is talking. This allows you
<br>  to have characters talking in the background while the player does other
<br>  things. Note that the character's talking animation is not played if this
<br>  function is used.
<br>  SeeAlso: DisplaySpeech
<br>EnableCursorMode (int mode)
<br>  Re-enables the mouse cursor mode MODE. This function also enables any
<br>  interface buttons which were disabled by the DisableCursorMode command.
<br>  SeeAlso: DisableCursorMode
<br>EnableHotspot (int hsnum)
<br>  Turns hotspot HSNUM back on. Use this to re-enable a hotspot which you
<br>  turned off earlier with the DisableHotspot command.
<br>  SeeAlso: DisableHotspot, RestoreWalkableArea
<br>EnableInterface ()
<br>  Re-enables the player interface, which was previously disabled with
<br>  the DisableInterface function. Everything which was disabled is returned
<br>  to normal.
<br>  SeeAlso: DisableInterface, IsInterfaceEnabled
<br>FaceCharacter (CHARID, int tofaceid)
<br>  Turns the graphic of character CHARID so that it looks like he is facing
<br>  character TOFACEID. This involves changing the current loop of CHARID
<br>  to the appropriate loop number, and setting the frame number to 0 (standing).
<br>  SeeAlso: FaceLocation, MoveCharacter
<br>FaceLocation (CHARID, int x, int y)
<br>  Similar to the FaceCharacter function, except that this faces the character
<br>  to screen location (X,Y). This allows him to face not only other characters,
<br>  but also objects and hotspots as well (you can get their co-ordinates from
<br>  the Ask Position feature in the Room Editor).
<br>  SeeAlso: FaceCharacter
<br>FadeIn (int speed)
<br>  Fades in from a black screen to the current palette. This is used to restore
<br>  the screen after a FadeOut call. SPEED is from 1 (slowest) to 64 (fastest).
<br>  Note: This is a blocking function.
<br>  Note: This function does not work in hi-color modes.
<br>  SeeAlso: CyclePalette, FadeOut
<br>FadeOut (int speed)
<br>  Fades the screen out to black. SPEED is the speed of the fade, from 1
<br>  (slowest) to 64 (instant). You can restore the screen with FadeIn.
<br>  Note: This is a blocking function.
<br>  Note: This function is slow in hi-color modes.
<br>  SeeAlso: CyclePalette, FadeIn
<br>FileClose (int handle)
<br>  Closes the file with handle HANDLE, and commits all changes to disk.
<br>  You MUST close the file after you have finished with it.
<br>  SeeAlso: FileOpen
<br>FileOpen (string filename, int mode)
<br>  Opens a disk file for reading or writing. These disk I/O functions are only
<br>  intended for simple tasks like the way the QFG series export the character
<br>  when you complete it. MODE is either FILE_READ or FILE_WRITE, depending on
<br>  whether you want to write to or read from the file. If you pass FILE_WRITE
<br>  and a file called FILENAME already exists, it will be overwritten.
<br>  This function returns a file handle, which you use in future calls to
<br>  file functions, or returns 0 if there was a problem (eg. file not existing
<br>  when MODE is FILE_READ).
<br>  Example (of writing a file):
<br>    int handle = FileOpen (&quot;temp.tmp&quot;, FILE_WRITE);
<br>    if (handle == 0) Display(&quot;Error opening file.&quot;);
<br>    else {
<br>      FileWrite (handle, &quot;test string&quot;);
<br>      FileClose (handle);
<br>      }
<br>  IMPORTANT: This function will ONLY work with files in the game directory.
<br>  You CANNOT use a path, so any filename with &quot;\&quot; or &quot;/&quot; in it will
<br>  automatically be rejected, for security reasons.
<br>  SeeAlso: FileClose, FileRead, FileWrite
<br>FileRead (int handle, string buffer)
<br>  Reads a string into BUFFER, from a file previously opened with FileOpen
<br>  which returned HANDLE. You should only use this with files which you
<br>  previously wrote out with FileWrite. Do NOT use this function with any
<br>  other files, even text files.
<br>  SeeAlso: FileOpen, FileWrite
<br>FileReadInt (int handle)
<br>  Reads an integer from the file HANDLE, and returns it to the script.
<br>  Only integers written with FileWriteInt can be read back.
<br>  SeeAlso: FileRead, FileWriteInt
<br>FileReadRawChar (int handle)
<br>  Reads a raw character from the input file HANDLE and returns it. This
<br>  function allows you to read from files that weren't created by your game,
<br>  however it is recommended for expert users only.
<br>  SeeAlso: FileRead, FileReadRawInt
<br>FileReadRawInt (int handle)
<br>  Reads a raw 32-bit integer from the input file and returns it to the script.
<br>  This allows you to read from files created by other programs - however, it
<br>  should only be used by experts as no error-checking is performed.
<br>  SeeAlso: FileRead, FileReadRawChar
<br>FileWrite (int handle, string text)
<br>  Writes TEXT to the file HANDLE, which must have been previously opened
<br>  with FileOpen for writing. The string is written using a custom format to
<br>  the file, which can only be read back by using FileRead.
<br>  SeeAlso: FileRead, FileOpen, FileWriteRawLine
<br>FileWriteInt (int handle, int value)
<br>  Writes VALUE to the file HANDLE. This allows you to save the contents of
<br>  variables to disk. The file must have been previously opened with FileOpen,
<br>  and you can read the value back later with FileReadInt.
<br>  SeeAlso: FileReadInt, FileWrite
<br>FileWriteRawLine (int handle, string text)
<br>  Writes a string of text to the file in plain text format. This enables
<br>  you to read it back in Notepad or any editor; however, your game cannot
<br>  read the file back in. This is useful for generating logs and such like.
<br>  The TEXT will be printed to the file, followed by the newline characters.
<br>  SeeAlso: FileWrite
<br>FlipScreen (int way)
<br>  Flips the screen round either the horizontal or vertical axis, or both.
<br>  This function is for special effects only - all co-ordinates remain the
<br>  same and it doesn't effect any other script functions.
<br>  The value of WAY selects:
<br>   0  normal
<br>   1  horizontal-flip (upside-down)
<br>   2  vertical-flip  (left-to-right)
<br>   3  both (upside-down and backwards)
<br>  NOTE: This function is still a bit buggy - black parts of the screen may
<br>  show up wrong, and and pop-up messages will flip the screen back to normal.
FollowCharacter (CHARID, int chartofollow)
<br>  Tells the character CHARID to follow CHARTOFOLLOW around, wherever he goes.
<br>  You could use this command to have a group of main characters who go around
<br>  together, or for example when the hero has rescued someone from the bad
<br>  guy, they can follow the hero home.
<br>  Pass CHARTOFOLLOW as -1 to stop the character following.
<br>  SeeAlso: FollowCharacterEx
<br>FollowCharacterEx (CHARID, int chartofollow, int dist, int eagerness)
<br>  Does the same thing as FollowCharacter (see above), but allows you to set
<br>  extra parameters. DIST sets how far away from CHARTOFOLLOW that CHARID will
<br>  stand. If DIST is 1, they will try to stand very close; if DIST is for
<br>  example 20, they will stand about 20 pixels away.
<br>  EAGERNESS sets on average how long the character will stand around before
<br>  checking if he needs to move again. Setting this to 0 means that he will
<br>  always be on the move until he reaches CHARTOFOLLOW; setting this to 99
<br>  means that he will pause and think for a while on route. Values in between
<br>  specify different lengths of idle time.
<br>  The default values are DIST=10 and EAGERNESS=97.
<br>  As a special case, setting DIST=0 and EAGERNESS=0 makes CHARID behave as if
<br>  it is chasing CHARTOFOLLOW - it will try and get there as quickly as possible.
<br>  Setting EAGERNESS=0 also tells the character not to stop when they reach
<br>  CHARTOFOLLOW, but instead to randomly wander around the character - useful
<br>  perhaps for a very energetic dog or something.
<br>  SeeAlso: FollowCharacter
<br>GetBackgroundFrame()
<br>  Returns the number of the current background being displayed. In a room
<br>  without animating backgrounds, this will always return 0. Otherwise, the
<br>  current frame number is returned from 0 to 4.
<br>  SeeAlso: SetBackgroundFrame
<br>GetCharacterAt (int x, int y)
<br>  Checks if there is a character at SCREEN co-ordinates (X,Y).
<br>  Returns the character number if there is, or -1 if there is not.
<br>  See the description of GetLocationName for more on screen co-ordinates.
<br>  NOTE: Any characters with the &quot;No interaction&quot; flag set will not be seen
<br>  by this function.
<br>  SeeAlso: GetHotspotAt, GetObjectAt, GetLocationName
<br>GetCurrentMusic()
<br>  Returns the number of the currently playing background music, or -1 if
<br>  no music is playing.
<br>  SeeAlso: IsMusicPlaying, IsSoundPlaying, SetMusicRepeat, SetMusicVolume
GetCursorMode()
<br>  Returns the value of the current mode of the cursor. This is either
<br>  MODE_LOOK, MODE_USE, MODE_TALK or any custom modes you have created.
<br>  SeeAlso: SetCursorMode
<br>GetGameSpeed ()
<br>  Returns the current game speed (number of cycles per second).
<br>  SeeAlso: SetGameSpeed
<br>GetGlobalInt (int index)
<br>  Returns the value of global variable INDEX.
<br>  SeeAlso: SetGlobalInt
<br>GetGUIAt (int x, int y)
<br>  Checks whether there is currently a GUI at screen co-ordinates (X,Y). If
<br>  there is, returns its GUI number.
<br>  If there is not currently a displayed, clickable GUI at the location,
<br>  returns -1.
<br>  SeeAlso: GetGUIObjectAt
<br>GetGUIObjectAt (int x, int y)
<br>  Checks whether there is a GUI object at screen co-ordinates (X,Y). Returns
<br>  its object (button) number if there is, or -1 if there is not. You probably
<br>  want to use this in conjunction with GetGUIAt.
<br>  SeeAlso: GetGUIAt
<br>GetHotspotAt (int x, int y)
<br>  Returns the number of the hotspot at SCREEN co-ordinates (X,Y).
<br>  If there is no hotspot there, or if invalid co-ordinates are specified,
<br>  returns 0.
<br>  See the description of GetLocationName for more on screen co-ordinates.
<br>  SeeAlso: GetLocationName, GetLocationType
<br>GetInvName (int item, string buffer)
<br>  Fills in BUFFER with the name of inventory item index ITEM. This is the
<br>  name which the item is given under the Game tab, Inventory mode of the Room
<br>  Editor.
<br>  This function is mainly useful for a lucasarts-style status line:
<br>   GetInvName (player.activeinv, buffer);
<br>  SeeAlso: GetLocationName
<br>GetLanguageString (int index, string buffer)
<br>  Reads the language text string INDEX into BUFFER. The AGS language
<br>  definition files consist of a collection of numbered strings with various
<br>  system text in a particular language. Whenever possible, you should use
<br>  this function rather than putting text directly into your script file, as
<br>  it gives flexibility and multilingual support.
<br>  For example, if you wanted to display a message &quot;Do you want to see the
<br>  intro?&quot;, you should check the message file, and find that message 300
<br>  reads &quot;Do you want to watch the introduction?&quot;. In this case, you should
<br>  then use GetLanguageString(300,buffer) rather than using your text directly.
<br>  You can add your own custom strings to the message files by using message
<br>  numbers of 500 and above.
<br>GetLocationName (int x, int y, string buffer)
<br>  Fills in BUFFER with the name of whatever is on the screen at (X,Y). This
<br>  allows you to create the Lucasarts-style status lines reading &quot;Look at xxx&quot;
<br>  as the player moves the cursor over them.
<br>  NOTE: The co-ordinates are SCREEN co-ordinates, NOT ROOM co-ordinates. This
<br>  means that with a scrolling room, the co-ordinates you pass are relative to
<br>  the screen's current position, and NOT absolute room co-ordinates. This
<br>  means that this function is suitable for use with the mouse cursor position
<br>  variables.
<br>  For example,  GetLocationName(mouse.x, mouse.y, buffer);
<br>  SeeAlso: GetInvName, GetLocationType
<br>GetLocationType (int x, int y)
<br>  Returns what type of thing is at location (X,Y); whether it is a character,
<br>  object, hotspot or nothing at all. This may be useful if you want to
<br>  process a mouse click differently depending on what the player clicks on.
<br>  NOTE: The co-ordinates are screen co-ordinates, NOT room co-ordinates. See
<br>  description of GetLocationName for more info.
<br>  The value returned means that the location is:
<br>   0   nothing, GUI or inventory
<br>   1   a hotspot
<br>   2   a character
<br>   3   an object
<br>  SeeAlso: GetHotspotAt, GetLocationName, GetObjectAt
<br>GetMIDIPosition ()
<br>  Returns the current MIDI beat number of the current track. If there is
<br>  no track playing, or if it's not a MIDI track, returns -1.
<br>  SeeAlso: SeekMIDIPosition
<br>GetObjectAt (int x, int y)
<br>  Checks if there is a room object at SCREEN co-ordinates (X,Y).
<br>  Returns the object number if there is, or -1 if there is not.
<br>  See the description of GetLocationName for more on screen co-ordinates.
<br>  SeeAlso: GetHotspotAt, GetLocationName
<br>GetObjectGraphic (int object)
<br>  Returns the current slot number that OBJECT is displayed as.
<br>  SeeAlso: SetObjectGraphic
<br>GetObjectX (int object)
<br>  Returns the X co-ordinate of room object number OBJECT.
<br>  SeeAlso: GetObjectY, IsObjectAnimating, SetObjectPosition
<br>GetObjectY (int object)
<br>  Returns the Y co-ordinate of room object number OBJECT.
<br>  SeeAlso: GetObjectX, IsObjectAnimating, SetObjectPosition
<br>GetPlayerCharacter ()
<br>  Returns the current character which the player is controlling.
<br>  SeeAlso: SetPlayerCharacter
<br>GetSaveSlotDescription (int slot, string buffer)
<br>  Gets the text description of save game slot SLOT into the provided BUFFER.
<br>  If the slot number provided does not exist this function returns 0, if
<br>  successful it returns 1.
<br>  SeeAlso: RestoreGameSlot, SaveGameSlot
<br>GetSliderValue (int gui, int object)
<br>  Returns the value of slider OBJECT on GUI to your program. You would usually
<br>  use this command in the interface_click function to find out what value the
<br>  player has changed the slider to, in order to process their command.
<br>  SeeAlso: SetLabelText, SetSliderValue
<br>GetTextBoxText (int gui, int object, string buffer)
<br>  Retrieves the contents of textbox OBJECT on gui GUI into the BUFFER.
<br>  This allows you to find out what the player typed in, and to respond
<br>  appropriately.
<br>  SeeAlso: SetTextBoxText, StrCaseComp, StrComp
<br>GetTime (int whichvalue)
<br>  This function returns various values, representing the current system time.
<br>  You could use this for timing a loop, or for effects like telling the
<br>  player to go to bed, and so on.
<br>  The WHICHVALUE parameter controls what is returned:
<br>   1  current hour (0-23)
<br>   2  current minute (0-59)
<br>   3  current second (0-59)
<br>   4  current day (1-31)
<br>   5  current month (1-12)
<br>GetViewportX ()
<br>  Returns the X-offset of the current viewport in a scrolling room. This
<br>  allows you to find out what part of the room the player is looking at.
<br>  The co-ordinate returned is the left edge of the screen, and so it can
<br>  have a value between 0 and (ROOM WIDTH - 320).
<br>  If the room is a non-scrolling room, returns 0.
<br>  See the SetViewport function description for more information.
<br>  SeeAlso: GetViewportY, SetViewport
<br>GetViewportY ()
<br>  Returns the Y-offset of the current viewport in a scrolling room. This
<br>  allows you to find out what part of the room the player is looking at.
<br>  The co-ordinate returned is the top edge of the screen, and so it can
<br>  have a value between 0 and (ROOM HEIGHT - 200).
<br>  If the room is a non-scrolling room, returns 0.
<br>  SeeAlso: GetViewportX, SetViewport
<br>GiveScore (int score)
<br>  Adds SCORE to the player's score. This is preferable to directly modifying
<br>  the variable since it will play the score sound, update any status lines
<br>  and call the GOT_SCORE on_event function.
<br>  Note that SCORE can be negative, in which case the score sound is NOT played.
InputBox (string prompt, string buffer)
<br>  This function allows your script to read a string typed in by the user.
<br>  When this function is called it pops up a window asking the user to type
<br>  in a string, with PROMPT as the text in the window. What they type in will
<br>  be copied into BUFFER.
<br>  Note that this function only allows small strings (about 20 characters)
<br>  due to the size of the input box it uses.
<br>  SeeAlso: StringToInt
<br>InterfaceOff (int interface)
<br>  Turns interface element number INTERFACE off. It will no longer appear on
<br>  the screen (or, if it is a pop-up interface, it cannot be popped up).
<br>  SeeAlso: InterfaceOn
<br>InterfaceOn (int interface)
<br>  Turns interface element number INTERFACE on and displays it on the screen.
<br>  This can be used to display a previously turned off interface, or to bring
<br>  up a special interface like an inventory window.
<br>  If the specified interface is a script-only interface (set to &quot;On script
<br>  command&quot; in the Room Editor), then the game will be paused while the
<br>  interface is displayed, and you should use InterfaceOff as a reaction to
<br>  a button click in the interface to remove it.
<br>  SeeAlso: InterfaceOff, IsGamePaused
<br>InventoryScreen ()
<br>  Brings up the Sierra-style inventory window which allows the player to
<br>  select and manipulate inventory items. If they select one, the cursor mode
<br>  will be set to inventory-use (mode 4), and  character[EGO].activeinv  will
<br>  be set to the inventory item selected.
<br>  NOTE: This function does not actually bring up the window immediately;
<br>  instead, it will show the window when the current script function finishes
<br>  executing.
<br>  NOTE: If the player has no inventory items, global message 996 will be
<br>  displayed.
<br>IsButtonDown ( BUTTON )
<br>  Tests whether the user has the specified mouse button down. BUTTON is either
<br>  LEFT or RIGHT. Return 1 if the button is currently pressed, 0 if not. This
<br>  could be used to test the length of a mouse click and similar effects.
<br>  SeeAlso: IsKeyPressed
<br>IsGamePaused ()
<br>  Returns 1 if the game is currently paused, or 0 otherwise.
<br>  The game is paused when either the icon bar interface has been popped up,
<br>  or a &quot;script-only&quot; interface has been displayed with InterfaceOn. While
<br>  the game is paused, no animations or other updates take place.
<br>  SeeAlso: InterfaceOn
<br>IsGUIOn (int gui)
<br>  Checks whether the specified GUI is currently displayed or not. Returns 1
<br>  if it is, 0 if not.
<br>  SeeAlso: InterfaceOff, InterfaceOn
<br>IsInterfaceEnabled ()
<br>  Returns 1 if the player interface is currently enabled, 0 if it is disabled.
<br>  The user interface is disabled while the cursor is set to the Wait cursor -
<br>  ie. while the character is performing a blocking Walk, or other blocking
<br>  action.
<br>  SeeAlso: DisableInterface, EnableInterface
<br>IsKeyPressed (int keycode)
<br>  Tests whether the supplied key on the keyboard is currently pressed down
<br>  or not. You could use this to move an object while the player holds an
<br>  arrow key down, for instance.
<br>  KEYCODE is one of the ASCII codes from section 6.6, with some limitations:
<br>  since it tests the raw state of the key, you CANNOT pass the Ctrl+(A-Z)
<br>  or Alt+(A-Z) codes (since they are key combinations). You can, however,
<br>  use some extra codes which are listed at the bottom of the section.
<br>  Returns 1 if the key is currently pressed, 0 if not.
<br>  SeeAlso: IsButtonDown
<br>IsMusicPlaying ()
<br>  Returns 1 if the background music track is still playing. If you are using
<br>  the Repeat Music option, this will always return 1 since the music will
<br>  loop round when it finishes. Otherwise, this will return 0 once the
<br>  current track finishes.
<br>  SeeAlso: GetCurrentMusic
<br>IsObjectAnimating (int object)
<br>  Returns 1 if the specified OBJECT is currently animating.
<br>  Returns 0 if the object has finished its animation.
<br>  SeeAlso: IsObjectMoving, GetObjectX, GetObjectY
<br>IsObjectMoving (int object)
<br>  Returns 1 if the object is currently moving, or 0 if not.
<br>  SeeAlso: IsObjectAnimating
<br>IsSoundPlaying ()
<br>  Returns 1 if there is currently a sound effect playing. This could be
<br>  a manually started sound (eg. with PlaySound) or an automatic sound (eg.
<br>  with GiveScore).
<br>  If the sound has finished, or none was played, returns 0.
<br>  NOTE: Be careful with this function for actions like looping sounds, since
<br>  if the user doesn't have a sound card this will always return 0.
<br>  NOTE: This function does not report if background music is playing.
<br>  SeeAlso: GetCurrentMusic
<br>IsTimerExpired (int timer_id)
<br>  Checks whether the timer TIMER_ID has expired.
<br>  If the timeout set with SetTimer has elapsed, returns 1.
<br>  Otherwise, returns 0.
<br>  Note that this function will only return 1 once - after that, the timer
<br>  is placed into an OFF state where it will always return 0 until restarted.
<br>  SeeAlso: SetTimer
<br>IsVoxAvailable()
<br>  Returns whether the SPEECH.VOX file is being used by the game.
<br>  This could be useful if you have an optional speech download pack, and
<br>  you want to know whether the player has it or not.
<br>  Returns 1 if the speech files are available, 0 if not.
<br>ListBoxAdd (int gui, int object, string newitem)
<br>  Adds NEWITEM to the list box OBJECT on GUI. The item will be appended to
<br>  the end of the list.
<br>  SeeAlso: ListBoxClear, ListBoxDirList
<br>ListBoxClear (int gui, int object)
<br>  Removes all items from the specified list box.
<br>  SeeAlso: ListBoxAdd
<br>ListBoxDirList (int gui, int object, string filemask)
<br>  Fills the list box OBJECT on gui GUI with a list of filenames matching
<br>  the FILEMASK in the current directory. This could be useful if you have
<br>  various data files and the player can choose which one to load.
<br>  FILEMASK is a standard DOS/Windows search expression such as &quot;*.dat&quot;
<br>  or &quot;data*.*&quot;.
<br>  SeeAlso: ListBoxAdd, ListBoxClear, ListBoxSaveGameList
<br>ListBoxGetItemText (int gui, int object, int item, string buffer)
<br>  Fills BUFFER with the text from list item number ITEM in listbox OBJECT on
<br>  gui GUI. This is useful for finding out the name of the option the user
<br>  selected.
<br>  SeeAlso: ListBoxGetSelected
<br>ListBoxGetNumItems (int gui, int object)
<br>  Returns the number of items in the specified listbox. Valid item indexes
<br>  range from 0 to (numItems - 1).
<br>  SeeAlso: ListBoxGetItemText
<br>ListBoxGetSelected (int gui, int object)
<br>  Returns the index into the list of the currently selected item. The first
<br>  item is 0, second is 1, and so on. If no item is selected, returns -1.
ListBoxSaveGameList (int gui, int object)
<br>  Fills the specified listbox with the save game list, sorted correctly
<br>  with the most recent game at the top of the list.
<br>  The global  savegameindex  array is updated with the actual slot numbers
<br>  of the entries. So, you could do:
<br>    int index = ListBoxGetSelected (GUI_NUMBER, OBJECT_NUMBER);
<br>    RestoreGameSlot (savegameindex[index]);
<br>  NOTE: The save game list can only hold 20 save games. If ListBoxGetNumItems
<br>  returns 20 and you are doing a Save dialog box, you may want to make the
<br>  user replace an existing file rather than saving a new one.
<br>  SeeAlso: ListBoxDirList, ListBoxGetSelected, ListBoxGetNumItems
<br>ListBoxSetSelected (int gui, int object, int selection)
<br>  Changes the currently selected item in the list to SELECTION. Indexes start
<br>  at 0 for the first item, 1 for the second, and so on. If you specify an
<br>  item that does not exist (eg. -1), the highlight will be removed.
<br>LoseInventory (int what)
<br>  Removes inventory item WHAT from the current player character's inventory.
<br>  If they do not have the item, nothing happens.
<br>  SeeAlso: AddInventory
<br>MergeObject (int object)
<br>  Merges object number OBJECT into the background scene for this room.
<br>  By doing this, the object becomes part of the background and so does not
<br>  slow the game down. This is a 1-way operation - once the object has
<br>  been merged, it cannot be changed back and the state of the room is
<br>  permanently altered. Therefore you should only use this function if a game
<br>  event has occured that means the room is permanently changed.
<br>  NOTE: after calling this function, you cannot use the object any more and
<br>  it is permanently removed from the game.
<br>  NOTE: objects can only be merged if the object graphic was imported at
<br>  the same colour depth as the background graphic
<br>MoveCharacter (CHARID, int x, int y)
<br>  Moves the character CHARID from its current location to X,Y. CHARID can
<br>  be either the character's number (as GetPlayerCharacter returns) or its ID
<br>  set in the Room Editor. If the character cannot get to X,Y it will be moved
<br>  as close as possible.
<br>  Note: this function only works with characters which are on the current
<br>  screen.
<br>  Note: if you need to find out when the character has reached its destination,
<br>  use the  character[charid].walking  variable. See the variables section below
<br>  for more information.
<br>  SeeAlso: FaceCharacter, MoveCharacterToObject, MoveObject, StopMoving
MoveCharacterBlocking (CHARID, int x, int y, int direct)
<br>  Moves the character CHARID to location (X,Y), waiting until they arrive
<br>  there before returning to the script.
<br>  If DIRECT is 0, this acts like MoveCharacter; if it is 1 then this acts
<br>  like MoveCharacterDirect.
<br>  SeeAlso: MoveCharacter, MoveCharacterDirect
<br>MoveCharacterDirect (CHARID, int x, int y)
<br>  Moves the character CHARID from its current location to (X,Y) directly,
<br>  ignoring walkable areas on the screen. This is identical to the &quot;Move to,
<br>  ignore walls&quot; animation command.
<br>  SeeAlso: MoveCharacter, MoveCharacterStraight
<br>MoveCharacterStraight (CHARID, int x, int y)
<br>  Moves the character CHARID from its current location to (X,Y) in a straight
<br>  line as far as is possible before hitting a non-walkable area. This is
<br>  useful for use with the arrow keys for character movement, since it
<br>  guarantees that the character will move in a straight line in the direction
<br>  specified. This function is non-blocking.
<br>  SeeAlso: MoveCharacter, MoveCharacterDirect
<br>MoveCharacterToHotspot (CHARID, int hotspot)
<br>  Moves the character CHARID from its current location to the walk-to point
<br>  for the specified hotspot. If the hotspot has no walk-to point, nothing
<br>  happens.
<br>  This is a blocking call - control is not returned to the script until the
<br>  character has reached its destination.
<br>  SeeAlso: MoveCharacter, MoveCharacterToObject
<br>MoveCharacterToObject (CHARID, int object)
<br>  Moves the character CHARID from its current location to a position just below
<br>  the object OBJECT. This is useful for example, if you want the man to pick
<br>  up an object. Example:
<br>    MoveCharacterToObject (EGO, 0);
<br>    ObjectOff (0);
<br>    AddInventory (3);
<br>  This is a blocking call - control is not returned to the script until the
<br>  character has reached its destination.
<br>  SeeAlso: MoveCharacter, MoveCharacterToHotspot
<br>MoveObject (int object, int x, int y, int speed)
<br>  Starts the object OBJECT moving from its current location to (X,Y). It will
<br>  move at speed SPEED, which uses the same scale as the character Walk Speed
<br>  values in the Room Editor.
<br>  SeeAlso: MoveCharacter, MoveObjectDirect
<br>MoveObjectDirect (int object, int x, int y, int speed)
<br>  Starts OBJECT moving from its current location to (X,Y), ignoring all
<br>  walkable areas on the screen. The object will therefore move directly to
<br>  the destination in a straight line.
<br>  SeeAlso: MoveObject
<br>MoveOverlay (int overlay_id, int x, int y)
<br>  Repositions screen overlay OVERLAY_ID to have its upper-left corner
<br>  at (X,Y). The move is instant (ie. it doesn't gradually glide over to the
<br>  new position).
<br>  SeeAlso: CreateTextOverlay, RemoveOverlay
<br>MoveToWalkableArea (CHARID)
<br>  Places character CHARID in the nearest walkable area to its current
<br>  location. If the character is already on a walkable area, nothing happens.
<br>  Otherwise it is placed in the nearest available area.
<br>  This is useful for placing for example in the Player Enters Screen event
<br>  of a screen, to make sure the character can move if a NewRoomEx has been
<br>  issued to get there. You could also use this in on_event for ENTER_ROOM
<br>  to use whenever a player enters a room.
<br>NewRoom (int room_number)
<br>  Changes the room the player is in. This command unloads the current room
<br>  from memory and loads instead ROOMx.CRM, where X is room_number.
<br>  IMPORTANT: This command does not change the room immediately; instead, it
<br>  will perform the actual room change once your script function has finished
<br>  (This is to avoid problems with unloading the script while it is still
<br>  running). This means that you should not use any other commands which rely
<br>  on the new room (object positionings, and so on) after this command within
<br>  the same function.
<br>  SeeAlso: NewRoomEx
<br>NewRoomEx (int room_number, int x, int y)
<br>  Identical to NewRoom, except that the player character is placed at
<br>  co-ordinates (X,Y) in the new room.
<br>  SeeAlso: NewRoom
<br>ObjectOff (int object)
<br>  Turns object number OBJECT off. It will no longer be displayed in this room
<br>  until you use an ObjectOn command.
<br>ObjectOn (int object)
<br>  Turns object number OBJECT on. It may have been turned off previously with
<br>  ObjectOff or may have been set initially off in RoomEdit.
<br>ParseText (string text)
<br>  Stores the supplied user text string for later use by Said.
<br>  You need to call this command first with the user's input before using
<br>  the Said command. You probably want to call this inside the interface_click
<br>  function when your text box control is activated.
<br>  SeeAlso: Said
<br>PauseGame ()
<br>  Stops the engine processing character movement and animation, and other
<br>  game features. This has the same effect on the game as happens when a
<br>  script-only interface is popped up. The processing will not resume until
<br>  you call the UnPauseGame function.
<br>  SeeAlso: UnPauseGame
<br>PlayFlic (int flic_number, int options)
<br>  Plays a FLI or FLC animation. The game checks for FLICx.FLC and FLICx.FLI
<br>  (where X is FLIC_NUMBER) and if it finds one, plays it.
<br>  OPTIONS has these meanings:
<br>    0  player can't skip animation
<br>    1  player can press ESC to skip animation
<br>    2  player can press any key or click mouse to skip animation
<br>  +10 (ie.10,11,12) do not stretch to full-screen, just play at flc size
<br>  This is identical to the room interaction command &quot;Play FLI/FLC %d&quot;. The
<br>  game is paused while the animation plays.
<br>PlayMusic (int music_number)
<br>  Changes the currently playing background music to MUSICx.MID, MUSICx.MOD
<br>  or MUSICx.XM (where X is MUSIC_NUMBER). The game will search for the files
<br>  in that order until it finds one to play.
<br>  SeeAlso: PlaySound
<br>PlaySound (int sound_number)
<br>  Plays a WAV or VOC sound effect. The game will search for SOUNDx.VOC
<br>  and SOUNDx.WAV (where x is SOUND_NUMBER) and play it. This is identical to
<br>  the room interaction command &quot;Play sound %d&quot;.
<br>  Pass -1 as SOUND_NUMBER to stop any currently playing sounds.
<br>  SeeAlso: PlayMusic
<br>ProcessClick (int x, int y, int mode)
<br>  Simulates clicking the mouse on the location (X,Y) on the screen, in the
<br>  cursor mode MODE. Any conditions attached will be executed. For example,
<br>  ProcessClick (100, 50, MODE_LOOK);
<br>  will simulate clicking the mouse on co-ordinates (100,50) in the Look mode.
<br>  NOTE: This function ignores all interfaces and acts as though the point is
<br>  directly visible. In other words, if the co-ordinates you pass happen to
<br>  lie on a button on an interface, what actually happens will be as if the
<br>  user clicked behind the interface onto the actual screen.
<br>  Available cursor modes: MODE_WALK, MODE_LOOK, MODE_USE, MODE_TALK,
<br>  MODE_USEINV, MODE_PICKUP.
<br>  SeeAlso: RunHotspotInteraction
<br>QuitGame(int ask_first)
<br>  Exits the game and returns to the operating system (DOS, Windows, etc).
<br>  If ASK_FIRST is zero, it will exit immediately. If ASK_FIRST is not zero,
<br>  it will first display a message box asking the user if they are sure they
<br>  want to quit.
<br>Random (int max)
<br>  Returns a random number between 0 and MAX. This could be useful to do
<br>  various effects in your game.
<br>RawClearScreen (int colour)
<br>  The family of &quot;raw&quot; functions allow you direct access to the screen to
<br>  do whatever you want with it. However, anything you do with these functions
<br>  is permanent on the screen until the player leaves the room. They are
<br>  most useful for things like a character stats screen where you want to
<br>  print information directly to the screen.
<br>  This function clears the screen to the specified COLOUR. (this is a number
<br>  you can find in the Game, Palette mode of roomedit). Whatever is currently
<br>  on the background will be wiped.
<br>  NOTE: any GUIs you have will still appear on top of the screen, so if you
<br>  want complete control you'll need to turn the GUIs off too.
<br>  SeeAlso: RawSetColor
<br>RawDrawImage (int x, int y, int slot)
<br>  Draws image SLOT from the sprite manager onto the screen at location (X,Y).
<br>  SeeAlso: RawPrint, RawDrawLine
<br>RawDrawLine (int from_x, int from_y, int to_x, int to_y)
<br>  Draws a line from (FROM_X, FROM_Y) to (TO_X, TO_Y) in the current raw
<br>  drawing colour.
<br>  SeeAlso: RawSetColor, RawDrawTriangle
<br>RawDrawTriangle (int x1, int y1, int x2, int y2, int x3, int y3)
<br>  Draws a filled triangle in the current colour with corners at the points
<br>  (x1,y1), (x2,y2) and (x3,y3).
<br>  Well, don't look at me, you might find it useful for something :-)
<br>  SeeAlso: RawDrawImage, RawDrawLine
<br>RawPrint (int x, int y, string text, ...)
<br>  This function prints the specified TEXT to screen location (X,Y). It
<br>  accepts Display-style &quot;%d&quot; and &quot;%s&quot; arguments to display variable values.
<br>  The text will be printed using the normal font and the current raw colour.
<br>  SeeAlso: RawSetColor, SetNormalFont
<br>RawRestoreScreen ()
<br>  Restores the screen from the backup image created with RawSaveScreen.
<br>  Use this when you want to get back what was there before you started
<br>  drawing.
<br>  SeeAlso: RawSaveScreen
<br>RawSaveScreen ()
<br>  Makes a backup of the current background screen, in order that it can be
<br>  restored later. This could be useful to back up the original image before
<br>  writing over it, or to save a certain state of your drawing to restore
<br>  later. Only one raw backup image can exist at a time, so this overwrites
<br>  any previous saves you made.
<br>  NOTE: The backup image is lost when the player leaves the screen, or if
<br>  they load a saved game position. Therefore, this is best only for short-term
<br>  effects.
<br>  SeeAlso: RawRestoreScreen
<br>RawSetColor (int colour)
<br>  Sets the colour to be used for future raw drawing routines to COLOUR. This
<br>  is a number you can obtain from the Game, Palette mode in roomedit.
<br>  SeeAlso: RawClearScreen, RawDrawLine, RawPrint
<br>RefreshMouse ()
<br>  Updates the global variables &quot;mouse.x&quot; and &quot;mouse.y&quot; with the current
<br>  position of the mouse. Normally, these variables are set just before each
<br>  script function is executed. However, if you have a very long script where
<br>  the mouse may have moved since the start of the function, and you need the
<br>  exact current location, then RefreshMouse will update the variables.
ReleaseCharacterView (CHARID)
<br>  Allows the engine to automatically control the character's view, as normal.
<br>  Use this once you have finished doing the animation which you started with
<br>  the SetCharacterView command.
<br>  SeeAlso: SetCharacterView
<br>ReleaseViewport ()
<br>  Releases the lock on the screen viewport, allowing it to automatically
<br>  scroll around following the player character as normal.
<br>  SeeAlso: SetViewport
<br>RemoveOverlay (int overlay_id)
<br>  Removes the specified overlay from the screen. OVERLAY_ID is the value
<br>  returned from the overlay creation functions like CreateTextOverlay.
<br>  SeeAlso: CreateTextOverlay
<br>RemoveWalkableArea (int areanum)
<br>  Removes the walkable areas in colour AREANUM from the current room. You can
<br>  put the area back with RestoreWalkableArea.
<br>  NOTE: When the player leaves the screen, all the walkable areas are reset.
<br>  Therefore, if you want an area to remain off when they leave the screen,
<br>  you will need to set a flag, then run the RemoveWalkableArea command in
<br>  the &quot;Player enters screen&quot; event when they return.
<br>  SeeAlso: RestoreWalkableArea
<br>ResetRoom (int room_number)
<br>  Discards all the data that the engine has in memory about when the player
<br>  last visited ROOM_NUMBER, and resets it as if they'd never been there. The
<br>  next time the player goes to that room, all the objects and scripts will
<br>  be in their initial state (as set up in roomedit), and not how they were
<br>  when the player left the room. The &quot;First time enters screen&quot; event will be
<br>  run when they enter this room again.
<br>  This function is useful if you want to have a &quot;View intro&quot; option to allow
<br>  the player to watch an intro again - this function can reset all the
<br>  objects in the intro rooms to their starting positions.
<br>  NOTE: You cannot reset the current room (ie. the room that the player is in).
RestartGame ()
<br>  Restarts the game from the beginning.
<br>RestoreGameDialog ()
<br>  Displays the restore game dialog, where the player can select a previously
<br>  saved game position to restore.
<br>  The dialog is not displayed immediately; instead, it will be displayed when
<br>  the script function finishes executing.
<br>  SeeAlso: RestoreGameSlot, SaveGameDialog
<br>RestoreGameSlot (int slot)
<br>  Restores the game position saved into slot number SLOT. You might want to
<br>  use these specific slot functions if for example you only want to allow the
<br>  player to have one save game position rather than the usual 20. If this slot
<br>  number does not exist, an error message is displayed to the player but the
<br>  game continues. To avoid the error, use the GetSaveSlotDescription function
<br>  to see if the position exists before restoring it.
<br>  NOTE: The position will not be restored immediately; instead, it will be
<br>  restored when the script function finishes executing.
<br>  SeeAlso: GetSaveSlotDescription, RestoreGameDialog, SaveGameSlot
<br>RestoreWalkableArea (int areanum)
<br>  Makes the area AREANUM walkable again.
<br>  SeeAlso: RemoveWalkableArea
<br>RunCharacterInteraction (CHARID, int mode)
<br>  Processes the interaction list as if the player had clicked the mouse
<br>  on character CHARID in cursor mode MODE. MODE is one of the MODE_* constants
<br>  listed in the ProcessClick description.
<br>  SeeAlso: ProcessClick, RunHotspotInteraction
<br>RunDialog (int topic)
<br>  Starts a conversation using topic number TOPIC. This is identical to the
<br>  &quot;Run dialog topic %d&quot; room interaction command.
<br>  Note: The conversation will not start immediately; instead, it will be run
<br>  when the current script function finishes executing.
<br>  SeeAlso: SetDialogOption
<br>RunHotspotInteraction (int hotspot, int mode)
<br>  Processes the interaction list as if the player had clicked the mouse
<br>  on hotspot number HOTSPOT in the current room, using cursor mode MODE.
<br>  MODE is one of the MODE_* constants listed in the ProcessClick description.
<br>  May be useful with the text parser for simulating a mouse click if they
<br>  type specific words in.
<br>  SeeAlso: ProcessClick, RunCharacterInteraction, RunObjectInteraction
RunObjectInteraction (int object, int mode)
<br>  Processes the interaction list as if the player had clicked the mouse
<br>  on object number OBJECT in the current room, using cursor mode MODE.
<br>  MODE is one of the MODE_* constants listed in the ProcessClick description.
<br>  SeeAlso: ProcessClick, RunCharacterInteraction, RunHotspotInteraction
Said (string text)
<br>  Checks whether the player typed in TEXT in their input passed to ParseText.
<br>  Returns 1 if it matches, 0 otherwise.
<br>  See section 4.6 for a more detailed description.
<br>  SeeAlso: ParseText, SaidUnknownWord
<br>SaidUnknownWord (string buffer)
<br>  If a word not in the game dictionary was submitted to the last ParseText
<br>  call, then BUFFER is filled with the word. This allows you to display a
<br>  message like &quot;Sorry, this game doesn't recognise 'XXXX'.&quot;
<br>  Returns 1 if the player typed an unknown word, or 0 if all words were
<br>  recognised.
<br>  Example use:
<br>    string buffer;
<br>    if (SaidUnknownWord (buffer)) {
<br>      Display(&quot;You can't use '%s' in this game.&quot;, buffer);
<br>    }
<br>  SeeAlso: ParseText, Said
<br>SaveGameDialog ()
<br>  Displays the save game dialog, where the player can save their current
<br>  game position. If they select to save, then the game position will be saved.
<br>  SeeAlso: RestoreGameDialog, SaveGameSlot
<br>SaveGameSlot (int slot, string description)
<br>  Saves the current game position to the save game number specified by SLOT,
<br>  using DESCRIPTION as the textual description of the save position.
<br>  Be careful using this function, because you could overwrite one of the
<br>  player's save slots if you aren't careful.
<br>  The SaveGameDialog function uses slots numbered from 1 to 20, so if you
<br>  don't want to interfere with the player's saves, I would recommend saving
<br>  to slot numbers of 100 and above.
<br>  SeeAlso: RestoreGameSlot, SaveGameDialog
<br>SaveScreenShot (string filename)
<br>  Takes a screen capture and saves it to disk. The FILENAME must end in
<br>  either &quot;.BMP&quot; or &quot;.PCX&quot;, as those are the types of files which can be saved.
<br>  Returns 1 if the shot was successfully saved, or 0 if an invalid file
<br>  extension was provided. For example,   SaveScreenShot(&quot;capture.bmp&quot;);
SeekMIDIPosition (int position)
<br>  Seeks the currently playing MIDI file to midi beat number POSITION. If
<br>  the current track is not a MIDI track, has no effect.
<br>  SeeAlso: GetMIDIPosition
<br>SeekMODPattern (int pattern)
<br>  Jumps directly to PATTERN in the currently playing MOD/XM music. If the
<br>  pattern does not exist, the music will stop.
<br>SetActiveInventory (int inv_item)
<br>  Sets the current active inventory item for the current player character
<br>  to INV_ITEM. This function changes the player.activeinv variable, and also
<br>  sets up the mouse cursor as necessary.
<br>  To deselect the current inventory, pass INV_ITEM as -1.
<br>SetAreaLightLevel (int area, int level)
<br>  Changes walkable area number AREA to have light level LEVEL. This does
<br>  the same thing as the Light Level buttons in roomedit, but allows you to
<br>  change it at run-time.
<br>  AREA is from 1 to 15 (the walkable area number), and LEVEL is from -100
<br>  to 100. (0 is the defualt non-lit level).
<br>  NOTE: The light level will be reset when the player leaves the room,
<br>  so you need to use it in Player Enters Screen if you want a permanent
<br>  change.
<br>SetBackgroundFrame (int frame)
<br>  Locks the background to frame number FRAME of an animating-background
<br>  screen. (Values for FRAME are from 0 to 4). This allows you to use the
<br>  animating backgrounds feature for another purpose - you can have two
<br>  frames of the background, one for example with a spaceship crashed on it.
<br>  Then, once the right event has happened, call SetBackgroundFrame in the
<br>  Player Enters Screen event to set the background before the screen fades in.
<br>  Call SetBackgroundFrame(-1) to set the default animating frames.
<br>  The frame lock is released when the game changes rooms.
<br>  SeeAlso: GetBackgroundFrame
<br>SetButtonPic (int gui, int object, int which, int newslot)
<br>  Changes a GUI button's graphic to the one you specify. This could be used
<br>  as an indicator of whether a feature is switched on or off by changing its
<br>  picture. Sets object number OBJECT on gui GUI to NEWSLOT from the sprite
<br>  manager.
<br>  The WHICH parameter selects which picture to change. It can have these
<br>  values:
<br>   1  normal picture
<br>   2  mouse-over picture
<br>   3  button pushed picture
<br>  Note that you can pass NEWSLOT as -1 to disable the mouse-over and pushed
<br>  pictures. For example, if the GUI setup in roomedit specifies a pushed-pic,
<br>  but you want to change the main picture in the game (and so remove the
<br>  old pushed picture), you can do something like this:
<br>   SetButtonPic (2, 3, 1, new_picture);
<br>   SetButtonPic (2, 3, 3, -1);
<br>  which will change button 3 on GUI 2 to have normal picture NEW_PICTURE and
<br>  not have a pushed graphic.
<br>  SeeAlso: SetLabelText
<br>SetCharacterBaseline (CHARID, int baseline)
<br>  Changes CHARID's baseline to BASELINE. This allows you to set a specific
<br>  base line for the character, which works similarly to walk-behind area and
<br>  object baselines.
<br>  BASELINE can be from 1 to the height of the room (normally 200), or set it
<br>  to 0 to go back to using the character's feet as the baseline.
<br>  SeeAlso: SetObjectBaseline, SetWalkBehindBase
<br>SetCharacterClickable (CHARID, int is_clickable)
<br>  Sets whether the character CHARID is recognised as something which the
<br>  player can interact with. This allows you to modify the &quot;No interaction&quot;
<br>  tick-box set initially in RoomEdit.
<br>  If you pass IS_CLICKABLE as 1, then the player can look at, speak to, and
<br>  so on the character (as with the old Sierra games). If you pass IS_CLICKABLE
<br>  as 0, then if the player clicks on the character it will activate whatever
<br>  is behind them (as with the old Lucasarts games).
<br>  SeeAlso: SetObjectClickable
<br>SetCharacterIdle (CHARID, int idleview, int delay)
<br>  Changes the character CHARID's idle view to IDLEVIEW, with a timeout
<br>  of DELAY seconds of inactivity before it is played. Inactivity is defined
<br>  as when the character is not moving and not being animated.
<br>  Setting DELAY to 0 causes the idle view to be looped continuously when
<br>  the character is not moving - this is useful when for example the character
<br>  is swimming and they need to tread water when idle.
<br>  Pass IDLEVIEW as -1 to disable the idle view completely.
<br>SetCharacterIgnoreLight (CHARID, int ignore)
<br>  Allows you to dynamically modify the &quot;ignore lighting&quot; checkbox for the
<br>  character in roomedit. Pass IGNORE as 1 for this character to always look
<br>  the same, and not be affected by the light level of walkable areas.
<br>  Pass 0 for this character to behave as normal and be affected by area light
<br>  levels.
<br>SetCharacterIgnoreWalkbehinds (CHARID, int ignore)
<br>  Sets whether character CHARID is affected by walkbehind areas. Passing 0
<br>  (the default setting) means that the character will be placed behind walk-
<br>  behind areas according to the relevant baselines.
<br>  Passing 1 means that the character will never be placed behind a walk-behind
<br>  area. This is useful if for example you want to use the character as an
<br>  overlay to display rain or snow onto a scene.
<br>  SeeAlso: SetObjectIgnoreWalkbehinds
<br>SetCharacterSpeed (CHARID, int newspeed)
<br>  Changes the character CHARID's walking speed to NEWSPEED. The values
<br>  used for NEWSPEED are identical to those set in the Room Editor for
<br>  walking speed.
<br>  NOTE: This function CANNOT be called while the character is moving, so
<br>  you must stop him first.
<br>  SeeAlso: MoveCharacter, StopMoving
<br>SetCharacterTransparency (CHARID, int amount)
<br>  Sets character CHARID to be AMOUNT % transparent.
<br>  This works in a similar way to SetObjectTransparency - see that description
<br>  for more information.
<br>  SeeAlso: SetObjectTransparency
<br>SetCharacterView (CHARID, int view)
<br>  Sets character CHARID's view to VIEW. This can be used to perform animations
<br>  with charaters, for example bending down to pick something up, which don't
<br>  use the default view.
<br>  NOTE: This function locks the character's view to the specified view, so
<br>  that it can only be changed by other script commands (ie. it won't
<br>  automatically be changed by the program on shadow areas, screen changes,
<br>  etc). When you are done with the animation, call ReleaseCharacterView to
<br>  allow the program to take control back.
<br>  SeeAlso: AnimateCharacter, ChangeCharacterView, ReleaseCharacterView
SetCursorMode(int new_mode)
<br>  Changes the mouse cursor mode to NEW_MODE. The number you pass can be
<br>  obtained from the VISUAL&gt;CURSORS tab of the Room Editor. This function
<br>  changes both the appearance of the cursor and the mode used if the player
<br>  clicks on a hotspot.
<br>  SeeAlso: GetCursorMode, SetMouseCursor
<br>SetDefaultCursor()
<br>  Changes the appearance of the mouse cursor to the default for the current
<br>  cursor mode. Use this to restore the cursor picture after you changed it
<br>  with the SetMouseCursor function.
<br>SetDialogOption (int topic, int option, int new_state)
<br>  Changes whether an option in a conversation is available to the player or
<br>  not. This allows you to add extra options to a conversation once the player
<br>  has done certain things.
<br>  TOPIC is the topic number, from 0 to the number of topics - 1. Find this
<br>  out in the Room Editor.
<br>  OPTION is the option number within that topic, from 1 to whatever the
<br>  highest option is for that topic.
<br>  NEW_STATE controls what happens to this option. It can have the following
<br>  values:
<br>    0   The option is disabled - the player will not see it
<br>    1   The option is enabled - the player can now see and use it
<br>    2   The option is permanently disabled - no other command can ever turn
<br>        it back on again.
<br>  These are equivalent to the option-off, option-on, and option-off-forever
<br>  dialog commands.
<br>  SeeAlso: RunDialog, StopDialog
<br>SetGameSpeed (int new_speed)
<br>  Sets the game speed to NEW_SPEED frames per second, or as near as possible
<br>  to that speed. The default frame rate is 40 fps, but you can speed up or
<br>  slow down the game by using this function. Note that this speed is also the
<br>  rate at which the Repeatedly_Execute functions are triggered.
<br>  The NEW_SPEED must lie between 10 and 100. If it does not, it will be rounded
<br>  to 10 or 100. Note that if you set a speed which the player's computer cannot
<br>  handle (for example, a 486 will not be able to manage 80 fps), then it will
<br>  go as fast as possible.
<br>  NOTE: Because the mouse cursor is repainted at the game frame rate, at very
<br>  low speeds, like 10 to 20 fps, the mouse will appear to be jumpy and not
<br>  very responsive.
<br>  SeeAlso: GetGameSpeed
<br>SetGlobalInt (int index, int value)
<br>  Sets the global variable INDEX to VALUE. You can then retrieve this value
<br>  from any other script using GetGlobalInt.
<br>  There are 300 available global variables, from index 0 to 299.
<br>  SeeAlso: GetGlobalInt
<br>SetGUIPosition (int gui, int x, int y)
<br>  Moves the top-left corner of GUI to the new location (X,Y) on the screen.
<br>  This allows you to dynamically move GUIs around on the screen while the
<br>  game is running. The co-ordinates are screen co-ordinates, not room
<br>  co-ordinates, and use the same scale as in RoomEdit.
<br>SetInvDimensions (int width, int height)
<br>  Allows you to change the default width and height of the inventory item
<br>  picture slots used by the Lucasarts-style inventory window. By default,
<br>  the LEC inv window is made up of 40x22 pixel cells, but if all your
<br>  inventory item pictures are bigger or smaller than this, you can use this
<br>  function to adjust them.
<br>SetInvItemPic (int inv, int sprite_slot)
<br>  Changes inventory item INV's graphic to be slot number SPRITE_SLOT from
<br>  the Sprite Manager. This allows you to dynamically adjust an item's
<br>  picture in the inventory window during the game.
<br>SetLabelText (int gui, int object, string newtext)
<br>  Changes the text displayed in the specified label to NEWTEXT. The affected
<br>  label will be object OBJECT from GUI. You can find out a label's object
<br>  number by looking at the Properties window of the label.
<br>  This command allows you to change the text during the game, for example
<br>  to create a Lucasarts-style status line.
<br>  SeeAlso: SetButtonPic
<br>SetMouseCursor(int new_cursor)
<br>  Changes the appearance of the mouse cursor to NEW_CURSOR. Unlike
<br>  the SetCursorMode function (see above), this does not change the mode
<br>  used if the user clicks on a hotspot. This is useful for displaying a &quot;wait&quot;
<br>  cursor temporarily.
<br>  SeeAlso: ChangeCursorGraphic, SetCursorMode, SetDefaultCursor
<br>SetMusicMasterVolume (int volume)
<br>  Sets the overall music volume, from 0-100. This is slightly mofidied by the
<br>  individual room volume settings.
<br>  SeeAlso: SetMusicVolume
<br>SetMusicRepeat (int loopflag)
<br>  Tells the system whether to repeat background music tracks. LOOPFLAG is
<br>  either 1 (repeat, default) or 0 (don't repeat).
<br>  SeeAlso: SetMusicVolume
<br>SetMusicVolume (int volume)
<br>  Overrides the room volume setting and sets the volume to VOLUME instead.
<br>  The values range from 1 to 5, representing each stage in the RoomEdit
<br>  volume options (ie. 1=quietest, 5=loudest).
<br>  NOTE: The volume will be reset when the player enters a new room.
<br>  SeeAlso: SetMusicMasterVolume, SetSoundVolume, GetCurrentMusic
<br>SetNormalFont (int font_number)
<br>  Changes the font used for all in-game text, except speech. FONT_NUMBER must
<br>  be from 0 to the number of fonts you have. By default the only options are 0
<br>  and 1.
<br>  SeeAlso: SetSpeechFont
<br>SetObjectBaseline (int object, int baseline)
<br>  Changes OBJECT's baseline to BASELINE. This modifies the line you can
<br>  set in RoomEdit. You can disable the baseline (and revert to using the
<br>  base of the object's image on the screen) by passing 0 as the baseline.
<br>  Otherwise, the baseline is the Y screen co-ordinate you want to use,
<br>  normally from 1 to 200 unless you have a taller than usual room.
<br>  SeeAlso: SetCharacterBaseline, SetWalkBehindBase
<br>SetObjectClickable (int object, int is_clickable)
<br>  Sets whether the OBJECT is recognised as something which the player can
<br>  interact with.
<br>  If you pass IS_CLICKABLE as 1, then the player can look at, speak to, and
<br>  so on the object. If you pass IS_CLICKABLE as 0, then the object will not
<br>  respond to clicks and the mouse will activate whatever is behind the object.
<br>  This is useful if you are using the object for visual effects and don't
<br>  want it to be clicked on by the player.
<br>  SeeAlso: SetCharacterClickable, SetObjectIgnoreWalkbehinds
<br>SetObjectFrame (int object, int view, int loop, int frame)
<br>  Sets object number OBJECT's graphic to frame FRAME of loop LOOP of view
<br>  number VIEW. This is useful if you want the object to use the second loop
<br>  in a view for an animation, because using the SetObjectView function in
<br>  room startup code will cause loop 0 to breifly flash on the screen first.
<br>  SeeAlso: SetObjectView
<br>SetObjectGraphic (int object, int slot)
<br>  Sets the graphic for object number OBJECT to slot number SLOT. You can get
<br>  the slot number from the Sprite Manager in RoomEdit. If the object is
<br>  currently animating (from an AnimateObject command) then the animation will
<br>  be stopped.
<br>  SeeAlso: SetObjectFrame, SetObjectView
<br>SetObjectIgnoreWalkbehinds (int object, int ignore)
<br>  Sets whether object OBJECT is affected by walkbehind areas. Passing 0 (the
<br>  default setting) means that the object will be placed behind walk-behind
<br>  areas according to the relevant baselines.
<br>  Passing 1 means that the object will never be placed behind a walk-behind
<br>  area. This is useful if for example you want an object to be a picture on
<br>  a wall, and the wall can be walked behind - but you also want it to act
<br>  correctly in relation to characters, so changing its baseline wouldn't work.
<br>  SeeAlso: SetCharacterIgnoreWalkbehinds, SetObjectClickable
<br>SetObjectPosition (int object, int x, int y)
<br>  Changes the object number OBJECT's position to (X,Y). These co-ordinates
<br>  specify the lower-left hand corner of the object.
<br>  SeeAlso: GetObjectX, GetObjectY
<br>SetObjectTransparency (int object, int amount)
<br>  Sets OBJECT to be AMOUNT % transparent.
<br>  Setting AMOUNT to 100 means it is totally invisible, and lower values
<br>  represent varying levels of transparency. Pass AMOUNT as 0 to stop the
<br>  object being transparent.
<br>  NOTE: Transparency currently only works in hi-color games, and the object
<br>    must have been imported in hi-colour for the transparency to work.
<br>  NOTE: Having a large transparent object can significantly slow down the
<br>    engine.
<br>  SeeAlso: SetCharacterTransparency
<br>SetObjectView (int object, int view)
<br>  Sets object number OBJECT's view to VIEW. The graphic is set to the first
<br>  frame of loop 0 of the view.
<br>  SeeAlso: AnimateObject, SetObjectFrame
<br>SetPalRGB (int slot, int red, int green, int blue)
<br>  Changes the RGB components of one of the palette slots. The palette is
<br>  initially set up in RoomEdit, but you can override it during the game using
<br>  this function for special effects. The RED, GREEN and BLUE parameters each
<br>  range from 0 to 63 (as used in the Palette Editor).
<br>  If SLOT is a background slot, then this function's effect will last until
<br>  the player changes screen, when the palette is changed to the new room's
<br>  palette. If SLOT is not a background slot, the effect of this function is
<br>  permanent.
<br>  Note: This function will allow you to change the colours which are &quot;locked&quot;
<br>  in the Room Editor. However, you should not normally do this as it can
<br>  cause strange colours in the game.
<br>  SeeAlso: CyclePalette, FadeIn, FadeOut, UpdatePalette
<br>SetPlayerCharacter (int char_id)
<br>  Changes the character which the player controls to CHAR_ID. You can either
<br>  use the character's number, or the ID string set in the Room Editor.
<br>  This function will also cause the room to change to the room which the
<br>  chosen character is currently in. (It calls NewRoom with the character's
<br>  room, so the change won't happen until the end of the script).
<br>  Note: The &quot;player&quot; global variable is not updated with the new character;
<br>  so using &quot;player.x&quot;, &quot;player.name&quot; and so on will change the original
<br>  character, not the current player character.
<br>  SeeAlso: GetPlayerCharacter, NewRoom
<br>SetRestartPoint ()
<br>  Changes the game restart point to the current position. This means that
<br>  from now on, if the player chooses the Restart Game option, it will return
<br>  here.
<br>  This function is useful if the default restart point doesn't work properly
<br>  in your game - just use this function to move it.
<br>SetScreenTransition (int trans_type)
<br>  Changes the default screen transition. trans_type can be one of the
<br>  following:
<br>   TRANSITION_FADE
<br>   TRANSITION_INSTANT
<br>   TRANSITION_DISSOLVE
<br>  All future transitions will be done as specified until you call this
<br>  function again.
<br>SetSkipSpeech (int new_mode)
<br>  Changes whether the player can skip speech text by clicking the mouse.
<br>  This option is initially set in a checkbox in the Main tab of RoomEdit, but
<br>  this function allows you to change it at run-time.
<br>  The value of NEW_MODE means the following:
<br>   0  player can skip text by clicking mouse or pressing key
<br>   1  player can skip text by pressing key only, not by clicking mouse
<br>   2  player cannot skip text with mouse or keyboard
<br>   3  text does not time-out; player must click mouse or press key each time
SetSliderValue (int gui, int object, int value)
<br>  Changes the specified slider (object number OBJECT on GUI) to have the
<br>  new value VALUE. VALUE must lie between the MIN and MAX settings for the
<br>  slider, as set up in the GUI editor.
<br>  SeeAlso: GetSliderValue, SetLabelText
<br>SetSoundVolume (int volume)
<br>  Sets the sound effect volume. VOLUME ranges from 0-255, where 255 is the
<br>  loudest. This also effects MOD and XM music.
<br>  SeeAlso: SetMusicVolume
<br>SetSpeechFont (int font_number)
<br>  Changes the font used for character speech. FONT_NUMBER must be from 0
<br>  to the number of fonts you have. By default the only options are 0 and 1.
<br>  SeeAlso: SetNormalFont
<br>SetSpeechStyle (new_style)
<br>  Changes the way in which speech text is displayed. This modifies the setting
<br>  originally set in roomedit. NEW_STYLE can be:
<br>    SPEECH_LUCASARTS     speech text over character's head
<br>    SPEECH_SIERRA        close-up portrait of character
<br>    SPEECH_SIERRABKGRND  close-up portrait + background window for text
<br>    SPEECH_FULLSCREEN    QFG4-style full screen dialog pictures
<br>SetSpeechVolume (int volume)
<br>  Sets the volume for in-game speech. VOLUME ranges from 0-255, where 255 is
<br>  the loudest. The default speech volume is 255 so this function can only
<br>  be used to reduce the volume.
<br>  SeeAlso: SetMusicVolume, SetSoundVolume
<br>SetTalkingColor (CHARID, int newcolor)
<br>  Changes the character CHARID's speech text color to NEWCOLOR. This could
<br>  be useful if in a particular room, the background colour is very similar
<br>  to the speech colour, so you can override it using this function.
<br>  NEWCOLOR is the colour slot index from 0 to 255.
<br>SetTextBoxText (int gui, int object, string newtext)
<br>  Changes the text box OBJECT on gui number GUI to contain NEWTEXT. This
<br>  might be useful to reset the text box to blank after the user has typed
<br>  something in, or to fill in a default value.
<br>  SeeAlso: GetTextBoxText, SetLabelText
<br>SetTextOverlay (int overlay_id, int x, int y, int width, int font, int color, string text)
<br>  Similar to CreateTextOverlay, except that this function replaces an
<br>  existing overlay with the new text. This has two advantages over simply
<br>  using RemoveOverlay followed by CreateTextOverlay to change the text -
<br>  it is one function call, and it allows you to keep the same overlay ID
<br>  number.
<br>  SeeAlso: CreateTextOverlay, RemoveOverlay
<br>SetTimer (int timer_id, int timeout)
<br>  Starts timer TIMER_ID ticking - it will tick once every game loop (normally
<br>  40 times per second), until TIMEOUT loops, after which it will stop.
<br>  You can check whether the timer has finished by calling the IsTimerExpired
<br>  function.
<br>  Pass TIMEOUT as 0 to disable a currently running timer.
<br>  There are 20 available timers, with TIMER_IDs from 1 to 20.
<br>  SeeAlso: IsTimerExpired
<br>SetViewport (int x, int y)
<br>  Locks the screen viewport to having the top-left hand corner at (X,Y) in
<br>  a scrolling room. This allows you to manually pan across a scrolling room
<br>  or to have the screen follow a non-player character.
<br>  The lock is released when you either call ReleaseViewport or the player
<br>  changes rooms.
<br>  NOTE: The co-ordinates supplied are 320x200-scale co-ordinates, and will
<br>  be automatically multiplied up by the engine.
<br>  NOTE: This function has no effect if the current room isn't a scrolling room.
<br>  For example, to scroll around and follow character MAN in a specific room,
<br>  put this in the room's repeatedly execute event:
<br>    SetViewport (character[MAN].x - 160, character[MAN].y - 110);
<br>  SeeAlso: GetViewportX, GetViewportY, ReleaseViewport
<br>SetVoiceMode (int new_mode)
<br>  Changes whether voice speech is used with dialog lines. The default
<br>  is on if the voice file is present, or off otherwise.
<br>  Valid values are:
<br>   0  no voice, text only
<br>   1  both voice and text
<br>   2  voice only, no text
<br>  WARNING: you should only ever use mode 2 at the player's request to do so,
<br>  because there is no guarantee that they even have a sound card and so may
<br>  not understand what is going on.
<br>SetWalkBehindBase (int area, int baseline)
<br>  Changes the walk-behind AREA to have new BASELINE. This effectively allows
<br>  you to turn walk-behinds on and off, although you can do other tricks with
<br>  it as well. BASELINE is from 1 to the height of the room (normally 200) and
<br>  moves the line which you set originally in RoomEdit.
<br>  Passing BASELINE as 0 disables the walk-behind area, so that the player
<br>  will always walk in front of it.
<br>  Basically, if the character's feet are below BASELINE, he will be drawn in
<br>  front of it, otherwise he will be drawn behind it.
<br>  SeeAlso: SetObjectBaseline
<br>ShakeScreen (int amount)
<br>  Shakes the screen to simulate, for example, an earthquake. AMOUNT is
<br>  how much the screen shakes: 1 is hardly anything, and 25 is a lot.
<br>StopDialog ()
<br>  This command can only be used from within the dialog_request function. It
<br>  tells AGS that when dialog_request finishes, the whole conversation should
<br>  stop rather than continuing with the dialog script.
<br>  You can use this function to end the conversation depending on whether the
<br>  player has/does a certain thing.
<br>  SeeAlso: SetDialogOption
<br>StopMoving (CHARID)
<br>  Stops the character CHARID moving and sets its graphic to the standing frame
<br>  of the current loop.
<br>  SeeAlso: MoveCharacter
<br>StrCat (string str1, string str2)
<br>  Appends STR2 to the end of STR1. For example, if STR1 contains &quot;Hello&quot;
<br>  and STR2 contains &quot;world&quot;, then after this function has been called, STR1
<br>  will contain &quot;Helloworld&quot;.
<br>StrCaseComp (string str1, string str2)
<br>  Does a case-insensitive comparison of STR1 and STR2. Using this function,
<br>  &quot;Dog&quot;, &quot;dog&quot; and &quot;doG&quot; will all be considered equal.
<br>  Returns 0 if the two strings match, non-zero otherwise.
<br>StrComp (string str1, string str2)
<br>  Compares the strings STR1 and STR2. Returns zero if they are identical, and
<br>  non-zero if they are not.
<br>StrCopy (string str1, string str2)
<br>  Copies the contents of STR2 into STR1, overwriting STR1's original contents.
<br>  Use this instead of the assignment STR1=STR2 .
<br>StrFormat (string destination, string fmt, ...)
<br>  Processes the string FMT in the same way as the Display function does (ie.
<br>  replace %d and %s with values of variables), but instead of displaying it
<br>  on the screen, puts the result into DESTINATION.
<br>  For example,
<br>    StrFormat (buffer, &quot;The got_stuff variable is %d.&quot;, got_stuff);
<br>  SeeAlso: Display
<br>StringToInt (string str1)
<br>  Converts the string STR1 into an integer, and returns that value. Returns
<br>  zero if the string does not contain a number.
<br>  For example,
<br>  StringToInt(&quot;53&quot;);     would return 53.
<br>  StringToInt(&quot;hello&quot;);  would return 0.
<br>  This function is useful for processing strings input from the user.
<br>  SeeAlso: InputBox
<br>StrLen (string str1)
<br>  Returns the length, in characters, of the string STR1.
<br>TintScreen (int red, int green, int blue)
<br>  Tints the screen with the specified RGB values. RED, GREEN and BLUE range
<br>  from 1 to 100. For example, to tint a heavy dose of red, you could
<br>  call TintScreen (100, 50, 50);
<br>  Pass (0, 0, 0) to turn off the tinting and go back to how the screen
<br>  normally looks.
<br>  NOTE: This command is currently experimental, since it causes a massive
<br>  slowdown in the engine, especially at high resolutions. If you use it, you
<br>  should provide an option for the player to turn it off.
<br>  NOTE: This feature only works in hi-colour games.
<br>UnPauseGame ()
<br>  Resumes the game.
<br>  SeeAlso: PauseGame
<br>UpdateInventory ()
<br>  Updates the player's inventory display. If you add or remove inventory
<br>  items manually (ie. by using the character[].inv[] variables rather than
<br>  the AddInventory/LoseInventory functions), the display may not get updated.
<br>  In this case, after making your changes, call this function to update
<br>  what is displayed to the player.
<br>  SeeAlso: AddInventory, LoseInventory
<br>UpdatePalette()
<br>  Commits the changes you made to the game palette.
<br>  The text script global variable  palette[]  stores the state of all the
<br>  colours of the palette. You can access the red, green and blue components
<br>  with .r, .g and .b. The values range from 0 to 63.
<br>  For example,   palette[16].r = 60;   would make the black colour turn
<br>  bright red. When you actually change the variable, nothing happens. Call
<br>  this function to update the screen.
<br>  SeeAlso: SetPalRGB
<br>Wait (int time)
<br>  Pauses the script and lets the game continue for TIME loops. There are
<br>  normally 40 loops/second (unless you change it with SetGameSpeed), so using
<br>  a value of 80 will wait 2 seconds. Note that no other text scripts can
<br>  run while the Wait function is in the background.
<br>  SeeAlso: WaitKey
<br>WaitKey (int time)
<br>  Pauses the script and lets the game continue until EITHER:
<br>  (a) TIME loops have elapsed, or
<br>  (b) the player presses a key
<br>  Returns 0 if the time elapsed, or 1 if the player interrupted it.
<br>  SeeAlso: Wait
<p>
<font color=#00A000><u><b>6.4 TEXT SCRIPT GLOBAL VARIABLES</b></u></font><br>
<br>The following variables are available to your script. Those marked with
an asterisk * are read-only and should NOT be modified by your script.
<br> (For the characters, CHARID is the script ID name as set in the Room Editor).
*character[CHARID].x         X co-ordinate of the character (see Note1 below)
*character[CHARID].y         Y co-ordinate of the character
<br> character[CHARID].name      The character's full name
<br> character[CHARID].prevroom  The room it was in before this one
<br> character[CHARID].room      Which room the character is in
<br> character[CHARID].activeinv The currently selected inventory item (or -1)
<br> character[CHARID].inv[x]    Whether the character is carrying inventory X
*character[CHARID].walking   Whether the character is currently moving
*character[CHARID].animating Set to 1 while an AnimateCharacter animation runs
<br> character[CHARID].talkview  The character's talking view number minus 1
*character[CHARID].view      Current view of the character graphic (minus 1)
*character[CHARID].loop      Current loop of the character graphic
<br>*character[CHARID].frame     Current frame of the character's graphic
<br> game.debug_mode         Whether we are in debug mode or not.
<br> game.following_room_timer How long to wait before following char emerges in
<br>                           new room, default 150. (higher is longer).
<br>*game.items_per_line     Number of inventory items displayed per line (useful
<br>                           for working out how much to scroll the window down)
*game.num_inv_displayed  Number of inventory items which can be seen in the
<br>                           inventory window.
<br>*game.num_inv_items      Number of different inventory items which the current
<br>                           player is carrying.
<br>*game.score              The player's score.  (see Note2 below)
<br> game.sierra_inv_color   The background color of the sierra-style inventory.
<br> game.skip_display       Setting for how Display() messages are skipped;
<br>                           valid values are same as for SetSkipSpeech (def 3).
<br> game.speech_text_gui    The textwindow GUI number used for sierra-style spch.
<br> game.swap_portrait      Set to 1 to make sierra-style speech swap the portrait
<br>                           image from left to right when diff people talk.
<br> game.talkanim_speed     The animation speed for talking views (default 5).
<br> game.text_shadow_color  Color used for speech text shadow (default 16).
<br> game.text_speed         How long speech text stays on the screen. Default 15,
<br>                           lower number means shorter time.
<br> game.top_inv_item       Index of the first inventory item in the window
<br> game.total_score        Maximum possible score, initially set in roomedit.
<br> game.used_mode          Cursor mode used with last click (use with &quot;any click&quot;
<br>                           events to find out which mode was used)
<br> gs_globals[50]         The graphical script global flags (0=clear, 1=set)
*mouse.x                Mouse X co-ordinate when the script was started (0-319)
*mouse.y                Mouse Y co-ordinate when the script was started (0-199)
<br> palette[SLOT].r        The red component (0-63) of palette slot SLOT
<br> palette[SLOT].g        The green component (0-63) of palette slot SLOT 
<br> palette[SLOT].b        The blue component (0-63) of palette slot SLOT
<br> player.[x,y,name,...]  Alias to character[EGO]. Note: only set at game start,
<br>                          does not update if you change the player character.
<br> savegameindex[20]      Save game slot order - see the ListBoxSaveGameList
<br>                          description in text script reference for more info.
*system.screen_height   The vertical screen resolution (200 or 400) see Note3
*system.screen_width    The horizontal screen resolution (320 or 640)
<br>*system.color_depth     The color depth (8 or 16).
<br>*system.os              Interpreter version (1=AGS-DOS, 2=AGS-WIN).
<br>*system.windowed        How game is running: 0=full screen, 1=window
<br>Notes:
<br>(1) The character X &amp; Y co-ordinates may be modified as long as the character
<br>  is stationary; changing these while the character is moving will cause it
<br>  to start moving off in the wrong direction.
<br>(2) To modify the score, use the GiveScore function.
<br>(3) The system information is provided in order for your game to behave
<br>  differently if it needs to; however, do NOT use this information to force
<br>  the player to use a specific resolution. The AC engine is designed to allow
<br>  players with varying speeds of computer to enjoy the game at a playable
<br>  speed; people with a 486 would rather see blocky graphics at 320x200 than
<br>  be forced to run very slowly at 640x400.
<p>
<font color=#00A000><u><b>6.5 SYSTEM LIMITS</b></u></font><br>
<br>This section tells you the maximums for various parts of the system. If you
have been wondering &quot;How many rooms can I have?&quot; or something similar,
chances are this section will answer it.
<br>There are maximum...
<br>  10  objects per room
<br> 100  messages per room
<br> 500  global messages
<br>  10  commands per animation
<br>  10  commands per 'if' block of graphical script
<br> 299  rooms per game
<br>  98  inventory items
<br>5000  imported sprites
<br> 240  sprites per folder
<br> 200  views
<br>   8  loops per view
<br>  10  frames in each loop
<br>  50  characters
<br>  20  GUI elements
<br>  30  controls on each GUI
<br>  80  total GUI controls of each type
<br> 200  dialog topics
<br>2000  dialog-script messages
<br>  14  options per topic
<br>   8  screen overlays at a time
<br> 300  text script GlobalInts
<p>
If you think any of these limits is a serious problem, contact me and I can
probably increase it.
<p>
<font color=#00A000><u><b>6.6 ASCII CODE TABLE</b></u></font><br>
<br>This section lists the key codes which can be passed to  on_key_press  and
which keys they represent:
<br> 1..26     Ctrl-A .. Ctrl-Z
<br> 13        Enter (Ctrl-M is also Enter)
<br> 27        Escape
<br> 32        Space
<br> 48..57    '0' key .. '9' key
<br> 65..90    'A' .. 'Z'  (letters are always passed as uppercase)
<br> 316..325  Alt-Q/W/E/R/T/Y/U/I/O/P
<br> 330..338  Alt-A/S/D/F/G/H/J/K/L
<br> 344..350  Alt-Z/X/C/V/B/N/M
<br> 359..368  F1 .. F10
<br> 371       Home (numeric pad)
<br> 372       Up arrow
<br> 373       PgUp (numeric pad)
<br> 375       Left arrow
<br> 376       '5' (numeric pad)
<br> 377       Right arrow
<br> 379       End (numeric pad)
<br> 380       Down arrow
<br> 381       PgDn (numeric pad)
<br> 433..434  F11 .. F12
<br>Extra codes, which only work with IsKeyPressed (ie. on_key_press is never
called with these codes):
<br> 403       Left shift
<br> 404       Right shift
<br> 405       Left ctrl
<br> 406       Right ctrl
<br> 407       Alt
<p>
<font color=#00A000><u><b>6.7 GRAPHICAL SCRIPT COMMAND REFERENCE</b></u></font><br>
<br>While many of the graphical script commands mirror the behavior of the
standard Interaction commands with the same name, there are some extra
commands special to the graphical script:<ul>
<li>Clear flag FLAGNAME
<br>Sets the flag's state to &quot;Clear&quot;.</li>
<li>Every XX loops
<br>The indented commands are carried out once every XX game loops. There are
approximately 40 game loops per second, so specifing '40' will mean that
the commands will be carried out once a second. This is only useful with
the &quot;repeatedly execute&quot; room event.</li>
<li>If flag FLAGNAME is set
<br>The indented commands are only carried out if the specified flag is
<br>in its &quot;Set&quot; state.</li>
<li>If flag FLAGNAME is clear
<br>The indented commands are only carried out if the flag is in its &quot;Clear&quot;
state.</li>
<li>If inventory XX was used
<br>The indented commands are carried out if the player used inventory item XX
to cause the event. You use this with the ability to set Data column to 99
on a &quot;Use inv&quot; event (see section 6.1.1 for information).</li>
<li>If player has inv XX
<br>The indented commands are only carried out if the player has the specified
inventory item.</li>
<li>If timer expired
<br>The indented commands are carried out if XX loops have passed since
<br>the &quot;Set timer&quot; command was executed. (See &quot;set timer&quot;).
NOTE: There is only one timer, and it is global. That is, starting the
timer on one screen can trigger an &quot;if expired&quot; event on another screen
if the player changes screens before the timer expires.</li>
<li>Move man to object XX
<br>Walks the main character to the object number specified. This is a
<br>shortcut for having to create an animation just to move the man up to
<br>the object he is interacting with.
<br>The character is moved to 5 pixels below the bottom of the object.</li>
<li>Random chance 1 in XX
<br>Probably only useful with the &quot;repeatedly execute&quot; event, the indented
commands will be carried out if a random number selection by the game
<br>turns out. For example, if XX is 3, the command will probably be carried
out about once every three times the script is executed, but this isn't
gauranteed. This is useful for things like adding a flying bird to the
screen which would appear at random intervals while the player was on the
screen.</li>
<li>Set flag FLAGNAME
<br>Sets the specified flag's state to &quot;Set&quot;.</li>
<li>Set timer to XX loops
<br>Starts the user timer counting down from XX - that is, the timer will
<br>expire after XX loops. (See &quot;If timer expired&quot;). This is similar to the
&quot;Every XX loops&quot; command, except that the timer will expire XX loops FROM
WHEN THIS SET TIMER COMMAND IS EXECUTED. This means that you can set another
event to happen an exact time after this.
<br>NOTE: Using this command with XX as 0 will deactivate the timer.
<br>NOTE: The timer will be deactivated if the player leaves the room where it
was activated.</li>
</ul>
<br><font color=#00A000><u><b>6.8 ANIMATION EDITOR COMMANDS</b></u></font><br>
<br>This section describes all the commands available in the Animation Editor.
The editor is explained in section 3.2.6.
<br>For all of the commands, you set the Object number to the number of the
object you want the command to operate on (from 0 to number_of_objects), or
you can set it to 99, in which case the command refers to the player
<br>character.
<p>
 Set object view to %d
<br>    Changes the view assigned to the object. The '%d' is the number of the
<br>    view, from the status bar in the View Editor. This command also resets
<br>    the object's graphic to the first frame of loop 0 in the chosen view.
<br>    You can use a special view number 0, which is the main character's default
<br>    view. This is useful to put back the main character if you changed his
<br>    graphics during the game.
<br> Animate using loop %d
<br>    Starts the object animating using loop number '%d' of its current view.
<br>    The object will cycle through all the frames in the loop and then stop.
<br>    If the Wait column is set, the next command will not be executed until
<br>    the animation has finished.
<br>    If you set the &quot;second value&quot; number to 1 then the animation will repeat
<br>    continuosly. If it is 0 (default) the animation will run once then stop.
<br>    NOTE: Don't set the Wait column AND set &quot;second value&quot; to 1, or you will
<br>    be waiting a LONG time!
<br> Move to %d,%d
<br>    Starts the object moving to the specified co-ordinates. You can find out
<br>    the co-ordinates of a point by using the  Misc | Ask Position  feature
<br>    in RoomMake. If the Wait column is set, the next command will not be
<br>    executed until the object has reached its destination.
<br>    NOTE: If you specify a target point which cannot be reached, there will
<br>    be a short delay and then the next command will be executed immediately.
 Move to %d,%d no walls
<br>    Identical to &quot;Move to %d,%d&quot;, except that the object will move in a direct
<br>    path straight to the destination, ignoring all the walls on the screen.
<br>    This is useful if you want to have the man, for instance, walking into a
<br>    door once it's open (which would mean crossing the base of the door,
<br>    presumably a wall to the player). It can also be used to simulate flying
<br>    objects.
<br> Place at %d,%d
<br>    Moves the object's position to the location immediately. Note that this
<br>    will only work if the object is turned OFF. Useful with the &quot;player enters
<br>    screen&quot; event to move objects around or to place the main character
<br>    somewhere which isn't on a screen edge.
<br>    Note that the position specified is the BOTTOM LEFT of the object graphic.
<p>
<font color=#0000A0 size="+1"><u><b>7. FAQ &amp; Troubleshooting</b></u></font><br>
<br>This section is split up into three parts:<ul>
<li>frequently asked questions, which answers questions people have about
the system, rather than problems using it.</li>
<li>run-time engine problems, which deals with problems getting the engine
to run, sound card issues, crashes, and other game-independant problems.</li>
<li>game creation problems, which deals with common problems you are having
with your specific game.</li>
<li>known bugs, which lists problems known to exist with AGS and what to
do about them.</li>
</ul>
<br><font color=#00A000><u><b>7.1 FREQUENTLY ASKED QUESTIONS</b></u></font><br>
<p>
Q. Can I play an AVI file?
<br>A. No, not directly. However, you can convert an AVI file for use with the
<br>   program. You've probably noticed that AGS supports WAV files for sound
<br>   effects and FLI/FLC for animations. By using a &quot;Play sound&quot; command straight
<br>   before a &quot;Play FLC&quot; command the sound should be in sync with the animation.
<br>   To split an AVI file into WAV and FLC components, I recommend the excellent
<br>   Smacker tools (www.smacker.com) which are free to download and also do
<br>   a VERY good job of reducing true-color AVIs down to 256-colours.
<p>
Q. Why is AGS so slow compared to the original Sierra/Lucasarts games? I
<br>   could run Space Quest 3 on my 286, but AGS needs 16 Mb RAM????
<br>A. There are several reasons why AGS is not as fast, and more resource
<br>   hungry than the original games. First of all, AGS is not optimised for
<br>   speed, I admit that. Luckily however, most people these days have at
<br>   least a Pentium-class system so that's no big problem.
<br>   Second, consider that AGS supports up to 640x400 hi-colour resolution,
<br>   whereas the original Sierra/LEC games only did 320x200x256.
<br>   Thirdly, the Sierra/LEC systems were entirely script-based - that is, the
<br>   programmers created the game without any features like interaction lists,
<br>   GUI editors and Dialog editors. These features, while making AGS a lot
<br>   easier to use, also have their toll on memory and processor usage. If I
<br>   was to convert AGS to a script-only system, it would probably only need
<br>   a fraction of the system resources. But would you use it then?
<br>   Finally, yes I could spend a month or so optimising the engine to be as
<br>   fast as possible. However, you the users have made it clear that you
<br>   prefer new features and bug fixes to speed improvements, so that's what
<br>   I'm trying to give you.
<br>   At time of writing this (December 2000), a mid-range new PC is 750 MHz,
<br>   with most people currently using around a 450 MHz system. Therefore, I am
<br>   not going to spend a lot of time doing speed improvements just so it'll run
<br>   on your 486. Sorry, but that's the way it is.
<p>
Q. Are you going to do a Windows port of the editor?
<br>A. Probably some day, yes. However, it's something that I'll start from
<br>   scratch if I do it, so it'll take a long time to finish.
<p>
Q. It's a bit cheap, the way you use MS-DOS EDIT to edit the text scripts.
<br>   Why not have an integrated editor?
<br>A. An integrated text editor will probably come soon, but in order to release
<br>   the program as quickly as possible, I felt it best to leave a well-tested,
<br>   reliable editor there instead of delaying the release while I write my own
<br>   text editor. Also, this way you can use your favorite text editor instead by
<br>   copying it to EDIT.EXE in the RoomEdit directory.
<p>
Q. What's the deal with the license? What does it mean in plain English?
<br>A. Adventure Game Studio is swap-ware. That means, that if you use and like
<br>   the program, you should send me something in return. This could be a game
<br>   you have made using it, some new graphics, a new translation for the system
<br>   messages, or even money! You don't HAVE to do this though, if you're really
<br>   mean, and I won't hold it against you :-)
<br>   There is one requirement - if you want to SELL a game you make, for profit,
<br>   then you must contact me beforehand as there are some licensing issues
<br>   which you may need to be aware of.
<br>   When you finish your game, feel free to post it on the AGS Announcements
<br>   forum so that everyone can give it a go.
<p>
Q. Why the swapware license? Why aren't you charging for it?
<br>A. Because I want to. Mainly because if you see a program claiming to create
<br>   adventure games, but charging you a registration of $100 if you want to
<br>   distribute a game, you're not likely even to try it. A few people are doing
<br>   this, for example Twilight Software with their system, but at $40 for a
<br>   single user registration, just to make freeware games with it, that's a sure
<br>   way to make it unpopular. Remember &quot;Klik'n'play&quot;? Hmmm.....
<p>
<font color=#00A000><u><b>7.2 RUN-TIME ENGINE PROBLEMS</b></u></font><br>
<p>
Q. The engine quits with &quot;Aborting due to signal SIGxxxx, Shutting down
<br>   allegro&quot; and a load of numbers. What's going on?
<br>A. You may have found a bug in the engine. First of all, check that you
<br>   haven't done anything silly, like assigning a view number to an object
<br>   where the view doesn't exist.
<br>   Otherwise, try and work out when the problem happens - does it always
<br>   happen at the same time (like whenever you turn an object on).
<br>   Write down the list of numbers (each begins with &quot;0x&quot;) and mail me with
<br>   the problem. Even better, take a screen shot of the complete error display
<br>   and send me that.
<p>
Q. When I choose the 960x600 mode in Setup, the game appears in a box in the
<br>   middle of the screen surrounded by black borders. What's wrong?
<br>A. Nothing, that's just how it is. The reason: a monitor can only use certain
<br>   specific resolutions, like 320x200, 640x400, 640x480, 1024x768, and so on.
<br>   So, to get the 960x600 mode, AGS tells the monitor to use its 1024x768 mode,
<br>   and place the game window in the centre.
<p>
Q. Then why doesn't AGS support a 1024x768 mode?
<br>A. For compatibility. The lowest resolution supported is 320x200, and all
<br>   other supported resolutions are multiples of this. This gives 640x400 and
<br>   960x600. Without this, AGS would be stuck in 1024x768 and would not allow
<br>   different video modes. Whether you think that would be a good thing or
<br>   not isn't the issue :-)
<p>
Q. I don't get sound from my SB Live! soundcard.
<br>A. That's not a question.
<p>
Q. Ok, how do I get sound from my SB Live! soundcard?
<br>A. To get any sound at all, you need to have the SB16 emulation enabled. (The
<br>   SB Live install program should have done this for you).
<br>   First of all, run AGS Setup and change the MIDI music card to the &quot;General
<br>   MIDI&quot; option. This gives much better sounding MIDI music than the Sound
<br>   Blaster midi driver which is autodetected.
<br>   Secondly, digital sound. This appears to be an incompatibility between
<br>   the SB16 emulator which comes with the SB Live, and AGS's sound driver. As
<br>   far as I've tried it, you can get digital sound if you run AC from a Windows
<br>   DOS-prompt, but not if you restart in MS-DOS mode. If you have more luck
<br>   in MS-DOS mode, I'd like to hear about it. You can try setting the digital
<br>   sound driver to &quot;Sound Blaster Pro&quot; in Setup, as this is more compatible
<br>   than the SB16 driver. Also, the IRQ which the SB Live emulation program
<br>   uses can cause problems. Try setting the SB16 emulation to use various IRQ
<br>   lines (5, 7, 9 for example) until you find one which works.
<p>
Q. Where can I get a &quot;DOS mouse driver&quot;?
<br>A. If you have Windows installed, it comes with a DOS mouse driver, so just
<br>   try typing MOUSE and press return. If not, try typing C:\WINDOWS\MOUSE and
<br>   press return (change the directory if Windows is installed elsewhere).
<br>   If you don't have one, you can download the Microsoft DOS mouse driver
<br>   from Microsoft's web site.
<p>
Q. I don't get sound under Windows 2000!
<br>A. This is due to the way that Windows 2000 works, and cannot be fixed for
<br>   the DOS engine. You need to run the Windows version of the engine instead,
<br>   which will give you sound using DirectX.
<p>
<font color=#00A000><u><b>7.3 GAME CREATION PROBLEMS</b></u></font><br>
<p>
Q. How do I import this character I downloaded in CHA format?
<br>A. In Roomedit, go to the Visual, Characters tab and press 'I' on the keyboard.
<p>
Q. On my screen, I can't move the main character. Wherever I click to move him,
<br>   he just stands there.
<br>A. If the main character isn't on a walkable area, he will not be able to move.
<br>   Load the screen into the Room Editor, and check that the location where the
<br>   man is has a walkable area there.
<br>   If you are upgrading from AC v1, you need to upgrade the room - see
<br>   section 5 for information.
<p>
Q. When I enter a certain room, I just get a black screen.
<br>A. Make sure that you haven't used a Display Message command in the &quot;Player
<br>   enters screen&quot; event for that room. Remember that this event happens BEFORE
<br>   the screen fades in.
<br>   To make sure, when you get the black screen, try pressing enter, or clicking
<br>   the left mouse button. If nothing happens then something more serious may
<br>   have happened. If this is the case, press Ctrl-Break, which should exit the
<br>   program and give you a list of numbers which you can send to me to
<br>   investigate.
<p>
Q. The character isn't drawn behind my walk-behind areas!
<br>A. You need to define the base line for the area, or he will always be drawn
<br>   in front. See section 3.1.2 for information.
<p>
Q. My USERGAME.EXE file seems to have disappeared.
<br>A. Because this file is your entire game, including the room files, when you
<br>   save a room in the Room Editor it will delete the exe file (because the
<br>   room contained in the exe is out of date). To get it back, simply save the
<br>   game again by going to the Game, Main tab and choosing the &quot;Save game&quot;
<br>   button.
<p>
Q. I get a message &quot;Exiting due to signal SIGxxxx, Shutting down Allegro&quot;
<br>   and it says it &quot;exited without requesting it&quot;.
<br>A. If you see a list of numbers, each starting with &quot;0x&quot;, please write them
<br>   down and contact me. Check that you haven't done anything silly, like used
<br>   a sprite or view number which doesn't exist.
<p>
<font color=#00A000><u><b>7.4 KNOWN BUGS</b></u></font><br>
<br>Please refer to the online Knowledge Base for a proper list of current
bugs and fixes. It's under the &quot;Support&quot; link on the AGS website. This
section of these docs is very rarely updated.
<br><ul>
<li>AGS does not run from a UNC-style network path (eg. running the game
from a path like \\MYCOMP\GAMES\AC.EXE ) - you will get a &quot;AC2GAME.DAT not
found&quot; error. The network drive must be mapped to a drive letter for the
game to run. For example, do this:
<br>NET USE V: \\MYCOMP\GAMES
<br>V:\AC.EXE</li>
<li>Roomedit has problems editing text scripts when 4DOS is running. If you
use 4DOS, please disable it before using roomedit.</li>
</ul>
<br>If you think you've found a different bug, first of all check out the
<br>Knowledge Base, and if it's not listed there post on the Technical forum
(info in section 8, below).
<p>
<font color=#0000A0 size="+1"><u><b>8. Contacting the author</b></u></font><br>
<br>If you have any comments/suggestions, the first place to go is the AGS
messageboard. Linked off the main AGS website, it's where the AGS community
meets and you will find answers to many questions there.
<br>If you think you've found a bug, if you need help or can't get it to work,
please check the following:<ul>
<li>That your question is not already answered in this file. AGS has been
painstakingly documented, so PLEASE read this file through before asking
me a question.</li>
<li>If it is not covered in this file, check the CHANGES.TXT file. If a new
feature has been added then it will be described there, if it has not yet
been added to this manual.</li>
<li>That you are using the most recent version of AGS. You can find out the
most recent version by checking the website (address below).
<br>You can find out your version by typing  ACDOS /?  and noting the line that
reads &quot;ACI version 2.xx.yyy&quot; (where 2.xx is the version number, and yyy
is the sub-version number).</li>
<li>If you are receiving an error message, please write down the EXACT message
and any other information which you think is appropriate. PLEASE WRITE THE
EXACT ERROR MESSAGE TEXT, don't just say &quot;I get a message about it not being
able to find a file&quot;.</li>
<li>If you are getting lock-ups or techno-garbage printouts, please try to
give a situation which causes the problem. For instance, if you notice that
it only happens on certain screens, or only if there is an object, etc then
please state that - it makes replying a lot easier and faster.</li>
</ul>
<br>Whatever the problem, if you can't solve it then post to the messageboard
for help. I also read the messageboard quite regularly, so chances are
someone will be able to help you.
<br>Please only e-mail me as a last resort, as I get too much e-mail as it is
and I actually check the messageboard more frequently than my mail.
<br>NOTE: If you want to mail me an attachment to demonstrate a problem you are
having, PLEASE COMPRESS IT using WinZip, PKZIP, etc and send it to me as a
zip file. I don't have the time or money to download massive 500 k BMP files
which compress to 20 k when zipped - if you send me an uncompressed BMP then
I will not respond to your mail.
<br>PLEASE NOTE: I usually check my e-mail two or three times a week, so give me
about a week to reply before assuming your message didn't get through. The
same applies to the message board.
<br>The AGS website: http://www.adventuregamestudio.co.uk
<br>The AGS forum:   http://pub6.ezboard.com/bdosuserforums
<br>My e-mail:  dosuser@bigfoot.com
<p>
<font color=#0000A0 size="+1"><u><b>9. Credits</b></u></font><br>
<br>The Adventure Game Studio v2 was programmed by Chris Jones.
<br>The DOS version uses DJGPP, a free 32-bit C/C++ compiler by DJ Delorie,
<br>  which you can get from http://www.delorie.com/djgpp/
<br>Graphics and sound are courtesy of the Allegro graphics library by Shawn
<br>  Hargreaves and many others. You can get it at
<br>  http://alleg.sourceforge.net/
<br>MP3 player is almp3 v1.5, by Javier Gonzalez and the FreeAmp team.
<br>Uses JGMOD mod player by Guan Foo Wah. You can find it at
<br>  http://surf.to/jgmod
<br>The demo game backgrounds and main character were drawn by D281@aol.com.
The icon bar graphics and Finnish translation were done by Teemu Eramaa
<br>  (teemue@nic.fi)
<br>The Dutch translation and the website logo were done by Erix Designs
<br>  (erixdesigns@hotmail.com).
<br>The German translation was done by Wolfram Guenther.
<br>The Portugese translation was done by Nuno Costa (ncosta@mail.telepac.pt).
The Norwegian translation was done by Martin Seterstoen (martin-s@online.no).
The Spanish translation was done by Javi G.G.
<br>The French translation was done by Pierre-Marc Jobin
<br>  (djobin1@globetrotter.qc.ca).
<br>The Lithuanian translation was done by Tomas J. (thebandit@takas.lt)
<br>The Slovenian translation was done by Janez Kranjc (janez.kranjc@amis.net)
The Bulgarian translation was done by Alexander Alexandrov.
<br>The Czech translation was done by Lukas Rachunek.
<br>The Polish translation was done by Jakub Offierski.
<br>The Swedish translation was done by Arn.
<br>The Italian translation was done by Mario from Naples.
<br>Includes CWSDPMI DPMI host (c) 1994-1997 by Charles W. Sandmann
<br>Executables compressed with DJP v1.07 (c) 1996-1998 by Laszlo Molnar
<p>
LEGAL STUFF
<br>Pentium is a trademark of Intel corporation.
<br>Windows is a trademark or registered trademark of Microsoft corp.
<p>
THIS SOFTWARE IS PROVIDED WITH ABSOLUTELY NO WARRANTY, NOT EVEN THE IMPLIED
WARRANTIES OF MERCHANTIBILITY OR FITNESS FOR A PARTICULAR PURPOSE.
<br>USE THIS SOFTWARE AT YOUR OWN RISK. CHRIS JONES IS NOT RESPONSIBLE IF YOUR
COMPUTER STARTS BURPING, CATCHES FIRE, GETS A SENSE OF HUMOUR OR ANYTHING
ELSE WHICH HAPPENS DUE TO THE USE OF THIS SOFTWARE.
<p>
SEE THE ACCOMPANYING LICENSE.TXT FILE FOR INFORMATION ON GAME DISTRIBUTION.

</body></html>
